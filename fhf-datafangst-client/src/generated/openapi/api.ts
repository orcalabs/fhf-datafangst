/* tslint:disable */
/* eslint-disable */
/**
 * web-api
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1.0
 * Contact: contact@orcalabs.no
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @enum {string}
 */

export const ActiveHaulsFilter = {
    Date: 'date',
    GearGroup: 'gearGroup',
    SpeciesGroup: 'speciesGroup',
    VesselLength: 'vesselLength',
    CatchLocation: 'catchLocation'
} as const;

export type ActiveHaulsFilter = typeof ActiveHaulsFilter[keyof typeof ActiveHaulsFilter];


/**
 * 
 * @export
 * @interface AisPosition
 */
export interface AisPosition {
    /**
     * 
     * @type {number}
     * @memberof AisPosition
     */
    'cog'?: number | null;
    /**
     * 
     * @type {AisPositionDetails}
     * @memberof AisPosition
     */
    'det'?: AisPositionDetails | null;
    /**
     * 
     * @type {number}
     * @memberof AisPosition
     */
    'lat': number;
    /**
     * 
     * @type {number}
     * @memberof AisPosition
     */
    'lon': number;
    /**
     * 
     * @type {string}
     * @memberof AisPosition
     */
    'timestamp': string;
}
/**
 * 
 * @export
 * @interface AisPositionDetails
 */
export interface AisPositionDetails {
    /**
     * 
     * @type {number}
     * @memberof AisPositionDetails
     */
    'distanceToShore': number;
    /**
     * 
     * @type {boolean}
     * @memberof AisPositionDetails
     */
    'missingData': boolean;
    /**
     * 
     * @type {NavigationStatus}
     * @memberof AisPositionDetails
     */
    'navigationalStatus'?: NavigationStatus | null;
    /**
     * 
     * @type {number}
     * @memberof AisPositionDetails
     */
    'rateOfTurn'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof AisPositionDetails
     */
    'speedOverGround'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof AisPositionDetails
     */
    'trueHeading'?: number | null;
}
/**
 * 
 * @export
 * @interface AisVessel
 */
export interface AisVessel {
    /**
     * 
     * @type {string}
     * @memberof AisVessel
     */
    'callSign'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AisVessel
     */
    'destination'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AisVessel
     */
    'eta'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof AisVessel
     */
    'imoNumber'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof AisVessel
     */
    'mmsi': number;
    /**
     * 
     * @type {string}
     * @memberof AisVessel
     */
    'name'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof AisVessel
     */
    'shipLength'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof AisVessel
     */
    'shipWidth'?: number | null;
}
/**
 * 
 * @export
 * @interface AisVmsPosition
 */
export interface AisVmsPosition {
    /**
     * 
     * @type {number}
     * @memberof AisVmsPosition
     */
    'cog'?: number | null;
    /**
     * 
     * @type {AisVmsPositionDetails}
     * @memberof AisVmsPosition
     */
    'det'?: AisVmsPositionDetails | null;
    /**
     * 
     * @type {number}
     * @memberof AisVmsPosition
     */
    'lat': number;
    /**
     * 
     * @type {number}
     * @memberof AisVmsPosition
     */
    'lon': number;
    /**
     * 
     * @type {number}
     * @memberof AisVmsPosition
     */
    'speed'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof AisVmsPosition
     */
    'timestamp': string;
}
/**
 * 
 * @export
 * @interface AisVmsPositionDetails
 */
export interface AisVmsPositionDetails {
    /**
     * 
     * @type {number}
     * @memberof AisVmsPositionDetails
     */
    'distanceToShore'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof AisVmsPositionDetails
     */
    'missingData': boolean;
    /**
     * 
     * @type {NavigationStatus}
     * @memberof AisVmsPositionDetails
     */
    'navigationalStatus'?: NavigationStatus | null;
    /**
     * 
     * @type {number}
     * @memberof AisVmsPositionDetails
     */
    'rateOfTurn'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof AisVmsPositionDetails
     */
    'trueHeading'?: number | null;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ApiError = {
    InvalidCallSign: 'InvalidCallSign',
    InvalidDateRange: 'InvalidDateRange',
    InternalServerError: 'InternalServerError',
    MissingMmsiOrCallSign: 'MissingMmsiOrCallSign'
} as const;

export type ApiError = typeof ApiError[keyof typeof ApiError];


/**
 * 
 * @export
 * @interface Catch
 */
export interface Catch {
    /**
     * 
     * @type {number}
     * @memberof Catch
     */
    'grossWeight': number;
    /**
     * 
     * @type {number}
     * @memberof Catch
     */
    'livingWeight': number;
    /**
     * 
     * @type {number}
     * @memberof Catch
     */
    'productQualityId': number;
    /**
     * 
     * @type {string}
     * @memberof Catch
     */
    'productQualityName': string;
    /**
     * 
     * @type {number}
     * @memberof Catch
     */
    'productWeight': number;
    /**
     * 
     * @type {number}
     * @memberof Catch
     */
    'speciesFiskeridirId': number;
}
/**
 * 
 * @export
 * @interface Delivery
 */
export interface Delivery {
    /**
     * 
     * @type {Array<Catch>}
     * @memberof Delivery
     */
    'delivered': Array<Catch>;
    /**
     * 
     * @type {number}
     * @memberof Delivery
     */
    'totalGrossWeight': number;
    /**
     * 
     * @type {number}
     * @memberof Delivery
     */
    'totalLivingWeight': number;
    /**
     * 
     * @type {number}
     * @memberof Delivery
     */
    'totalProductWeight': number;
}
/**
 * 
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
    /**
     * 
     * @type {string}
     * @memberof ErrorResponse
     */
    'description': string;
    /**
     * 
     * @type {ApiError}
     * @memberof ErrorResponse
     */
    'error': ApiError;
}


/**
 * 
 * @export
 * @interface FishingFacility
 */
export interface FishingFacility {
    /**
     * 
     * @type {string}
     * @memberof FishingFacility
     */
    'barentswatchVesselId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FishingFacility
     */
    'callSign'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FishingFacility
     */
    'comment'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FishingFacility
     */
    'contactEmail'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FishingFacility
     */
    'contactPhone'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FishingFacility
     */
    'geometryWkt': string;
    /**
     * 
     * @type {number}
     * @memberof FishingFacility
     */
    'imo'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof FishingFacility
     */
    'lastChanged': string;
    /**
     * 
     * @type {number}
     * @memberof FishingFacility
     */
    'mmsi'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof FishingFacility
     */
    'regNum'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FishingFacility
     */
    'removedProcessedTimestamp'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FishingFacility
     */
    'removedTimestamp'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FishingFacility
     */
    'sbrRegNum'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FishingFacility
     */
    'setupProcessedTimestamp'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FishingFacility
     */
    'setupTimestamp': string;
    /**
     * 
     * @type {string}
     * @memberof FishingFacility
     */
    'source'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FishingFacility
     */
    'toolColor'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof FishingFacility
     */
    'toolCount'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof FishingFacility
     */
    'toolId': string;
    /**
     * 
     * @type {number}
     * @memberof FishingFacility
     */
    'toolType': number;
    /**
     * 
     * @type {string}
     * @memberof FishingFacility
     */
    'toolTypeName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FishingFacility
     */
    'vesselName'?: string | null;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const FishingFacilityToolType = {
    Undefined: 'Undefined',
    Crabpot: 'Crabpot',
    Danpurseine: 'Danpurseine',
    Nets: 'Nets',
    Longline: 'Longline',
    Generic: 'Generic',
    Sensorbuoy: 'Sensorbuoy',
    Sensorcable: 'Sensorcable'
} as const;

export type FishingFacilityToolType = typeof FishingFacilityToolType[keyof typeof FishingFacilityToolType];


/**
 * 
 * @export
 * @interface FiskeridirVessel
 */
export interface FiskeridirVessel {
    /**
     * 
     * @type {number}
     * @memberof FiskeridirVessel
     */
    'buildingYear'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof FiskeridirVessel
     */
    'callSign': string;
    /**
     * 
     * @type {number}
     * @memberof FiskeridirVessel
     */
    'engineBuildingYear'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof FiskeridirVessel
     */
    'enginePower'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof FiskeridirVessel
     */
    'grossTonnage1969'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof FiskeridirVessel
     */
    'grossTonnageOther'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof FiskeridirVessel
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof FiskeridirVessel
     */
    'length'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof FiskeridirVessel
     */
    'lengthGroupId'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof FiskeridirVessel
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FiskeridirVessel
     */
    'nationGroupId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FiskeridirVessel
     */
    'nationId'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof FiskeridirVessel
     */
    'norwegianCountyId'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof FiskeridirVessel
     */
    'norwegianMunicipalityId'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof FiskeridirVessel
     */
    'owner'?: string | null;
    /**
     * 
     * @type {Array<RegisterVesselOwner>}
     * @memberof FiskeridirVessel
     */
    'owners'?: Array<RegisterVesselOwner> | null;
    /**
     * 
     * @type {number}
     * @memberof FiskeridirVessel
     */
    'rebuildingYear'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof FiskeridirVessel
     */
    'registrationId'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof FiskeridirVessel
     */
    'vesselTypeId'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof FiskeridirVessel
     */
    'width'?: number | null;
}
/**
 * 
 * @export
 * @interface Gear
 */
export interface Gear {
    /**
     * 
     * @type {number}
     * @memberof Gear
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof Gear
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface GearGroup
 */
export interface GearGroup {
    /**
     * 
     * @type {number}
     * @memberof GearGroup
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof GearGroup
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface GearMainGroup
 */
export interface GearMainGroup {
    /**
     * 
     * @type {number}
     * @memberof GearMainGroup
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof GearMainGroup
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface Haul
 */
export interface Haul {
    /**
     * 
     * @type {string}
     * @memberof Haul
     */
    'catchLocationStart'?: string | null;
    /**
     * 
     * @type {Array<HaulCatch>}
     * @memberof Haul
     */
    'catches': Array<HaulCatch>;
    /**
     * 
     * @type {number}
     * @memberof Haul
     */
    'duration': number;
    /**
     * 
     * @type {string}
     * @memberof Haul
     */
    'ersActivityId': string;
    /**
     * 
     * @type {number}
     * @memberof Haul
     */
    'fiskeridirVesselId'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof Haul
     */
    'gearGroupId': number;
    /**
     * 
     * @type {number}
     * @memberof Haul
     */
    'gearId': number;
    /**
     * 
     * @type {number}
     * @memberof Haul
     */
    'haulDistance'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof Haul
     */
    'haulId': string;
    /**
     * 
     * @type {number}
     * @memberof Haul
     */
    'oceanDepthEnd': number;
    /**
     * 
     * @type {number}
     * @memberof Haul
     */
    'oceanDepthStart': number;
    /**
     * 
     * @type {number}
     * @memberof Haul
     */
    'quotaTypeId': number;
    /**
     * 
     * @type {number}
     * @memberof Haul
     */
    'startLatitude': number;
    /**
     * 
     * @type {number}
     * @memberof Haul
     */
    'startLongitude': number;
    /**
     * 
     * @type {string}
     * @memberof Haul
     */
    'startTimestamp': string;
    /**
     * 
     * @type {number}
     * @memberof Haul
     */
    'stopLatitude': number;
    /**
     * 
     * @type {number}
     * @memberof Haul
     */
    'stopLongitude': number;
    /**
     * 
     * @type {string}
     * @memberof Haul
     */
    'stopTimestamp': string;
    /**
     * 
     * @type {string}
     * @memberof Haul
     */
    'vesselCallSign'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Haul
     */
    'vesselCallSignErs': string;
    /**
     * 
     * @type {number}
     * @memberof Haul
     */
    'vesselLength': number;
    /**
     * 
     * @type {number}
     * @memberof Haul
     */
    'vesselLengthGroup': number;
    /**
     * 
     * @type {string}
     * @memberof Haul
     */
    'vesselName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Haul
     */
    'vesselNameErs'?: string | null;
    /**
     * 
     * @type {Array<WhaleCatch>}
     * @memberof Haul
     */
    'whaleCatches': Array<WhaleCatch>;
}
/**
 * 
 * @export
 * @interface HaulCatch
 */
export interface HaulCatch {
    /**
     * 
     * @type {number}
     * @memberof HaulCatch
     */
    'livingWeight': number;
    /**
     * 
     * @type {number}
     * @memberof HaulCatch
     */
    'speciesFiskeridirId': number;
    /**
     * 
     * @type {number}
     * @memberof HaulCatch
     */
    'speciesGroupId': number;
}
/**
 * 
 * @export
 * @interface HaulsMatrix
 */
export interface HaulsMatrix {
    /**
     * 
     * @type {Array<number>}
     * @memberof HaulsMatrix
     */
    'dates': Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof HaulsMatrix
     */
    'gearGroup': Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof HaulsMatrix
     */
    'lengthGroup': Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof HaulsMatrix
     */
    'speciesGroup': Array<number>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const NavigationStatus = {
    UnderWayUsingEngine: 'UnderWayUsingEngine',
    AtAnchor: 'AtAnchor',
    NotUnderCommand: 'NotUnderCommand',
    RestrictedManoeuverability: 'RestrictedManoeuverability',
    ConstrainedByDraught: 'ConstrainedByDraught',
    Moored: 'Moored',
    Aground: 'Aground',
    EngagedInFishing: 'EngagedInFishing',
    UnderWaySailing: 'UnderWaySailing',
    Reserved9: 'Reserved9',
    Reserved10: 'Reserved10',
    Reserved11: 'Reserved11',
    Reserved12: 'Reserved12',
    Reserved13: 'Reserved13',
    AisSartIsActive: 'AisSartIsActive',
    NotDefined: 'NotDefined'
} as const;

export type NavigationStatus = typeof NavigationStatus[keyof typeof NavigationStatus];


/**
 * 
 * @export
 * @enum {string}
 */

export const Ordering = {
    Asc: 'asc',
    Desc: 'desc'
} as const;

export type Ordering = typeof Ordering[keyof typeof Ordering];


/**
 * 
 * @export
 * @enum {string}
 */

export const RegisterVesselEntityType = {
    Company: 'COMPANY',
    Person: 'PERSON'
} as const;

export type RegisterVesselEntityType = typeof RegisterVesselEntityType[keyof typeof RegisterVesselEntityType];


/**
 * 
 * @export
 * @interface RegisterVesselOwner
 */
export interface RegisterVesselOwner {
    /**
     * 
     * @type {string}
     * @memberof RegisterVesselOwner
     */
    'city'?: string | null;
    /**
     * 
     * @type {RegisterVesselEntityType}
     * @memberof RegisterVesselOwner
     */
    'entityType': RegisterVesselEntityType;
    /**
     * 
     * @type {number}
     * @memberof RegisterVesselOwner
     */
    'id'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof RegisterVesselOwner
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof RegisterVesselOwner
     */
    'postalCode': number;
}


/**
 * 
 * @export
 * @interface Species
 */
export interface Species {
    /**
     * 
     * @type {number}
     * @memberof Species
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof Species
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface SpeciesFao
 */
export interface SpeciesFao {
    /**
     * 
     * @type {string}
     * @memberof SpeciesFao
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof SpeciesFao
     */
    'name'?: string | null;
}
/**
 * 
 * @export
 * @interface SpeciesFiskeridir
 */
export interface SpeciesFiskeridir {
    /**
     * 
     * @type {number}
     * @memberof SpeciesFiskeridir
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof SpeciesFiskeridir
     */
    'name'?: string | null;
}
/**
 * 
 * @export
 * @interface SpeciesGroup
 */
export interface SpeciesGroup {
    /**
     * 
     * @type {number}
     * @memberof SpeciesGroup
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof SpeciesGroup
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface SpeciesMainGroup
 */
export interface SpeciesMainGroup {
    /**
     * 
     * @type {number}
     * @memberof SpeciesMainGroup
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof SpeciesMainGroup
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface Trip
 */
export interface Trip {
    /**
     * 
     * @type {{ [key: string]: Delivery; }}
     * @memberof Trip
     */
    'deliveredPerDeliveryPoint': { [key: string]: Delivery; };
    /**
     * 
     * @type {Delivery}
     * @memberof Trip
     */
    'delivery': Delivery;
    /**
     * 
     * @type {Array<string>}
     * @memberof Trip
     */
    'deliveryPointIds': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Trip
     */
    'end': string;
    /**
     * 
     * @type {string}
     * @memberof Trip
     */
    'endPortId'?: string | null;
    /**
     * 
     * @type {Array<VesselEvent>}
     * @memberof Trip
     */
    'events': Array<VesselEvent>;
    /**
     * 
     * @type {number}
     * @memberof Trip
     */
    'fiskeridirVesselId': number;
    /**
     * 
     * @type {Array<number>}
     * @memberof Trip
     */
    'gearIds': Array<number>;
    /**
     * 
     * @type {Array<Haul>}
     * @memberof Trip
     */
    'hauls': Array<Haul>;
    /**
     * 
     * @type {string}
     * @memberof Trip
     */
    'mostRecentDeliveryDate'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Trip
     */
    'numDeliveries': number;
    /**
     * 
     * @type {string}
     * @memberof Trip
     */
    'start': string;
    /**
     * 
     * @type {string}
     * @memberof Trip
     */
    'startPortId'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Trip
     */
    'tripId': number;
}
/**
 * 
 * @export
 * @interface Vessel
 */
export interface Vessel {
    /**
     * 
     * @type {AisVessel}
     * @memberof Vessel
     */
    'ais'?: AisVessel | null;
    /**
     * 
     * @type {FiskeridirVessel}
     * @memberof Vessel
     */
    'fiskeridir': FiskeridirVessel;
}
/**
 * 
 * @export
 * @interface VesselEvent
 */
export interface VesselEvent {
    /**
     * 
     * @type {number}
     * @memberof VesselEvent
     */
    'eventId': number;
    /**
     * 
     * @type {string}
     * @memberof VesselEvent
     */
    'eventName': string;
    /**
     * 
     * @type {number}
     * @memberof VesselEvent
     */
    'eventType': number;
    /**
     * 
     * @type {string}
     * @memberof VesselEvent
     */
    'timestamp': string;
}
/**
 * 
 * @export
 * @interface VmsPosition
 */
export interface VmsPosition {
    /**
     * 
     * @type {number}
     * @memberof VmsPosition
     */
    'course'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof VmsPosition
     */
    'lat': number;
    /**
     * 
     * @type {number}
     * @memberof VmsPosition
     */
    'lon': number;
    /**
     * 
     * @type {number}
     * @memberof VmsPosition
     */
    'speed'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof VmsPosition
     */
    'timestamp': string;
}
/**
 * 
 * @export
 * @interface WhaleCatch
 */
export interface WhaleCatch {
    /**
     * 
     * @type {number}
     * @memberof WhaleCatch
     */
    'blubberMeasureA'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof WhaleCatch
     */
    'blubberMeasureB'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof WhaleCatch
     */
    'blubberMeasureC'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof WhaleCatch
     */
    'circumference'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof WhaleCatch
     */
    'fetusLength'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof WhaleCatch
     */
    'genderId'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof WhaleCatch
     */
    'grenadeNumber': string;
    /**
     * 
     * @type {number}
     * @memberof WhaleCatch
     */
    'individualNumber'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof WhaleCatch
     */
    'length'?: number | null;
}

/**
 * V1aisApi - axios parameter creator
 * @export
 */
export const V1aisApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} mmsi 
         * @param {string} [start] 
         * @param {string} [end] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aisTrack: async (mmsi: number, start?: string, end?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mmsi' is not null or undefined
            assertParamExists('aisTrack', 'mmsi', mmsi)
            const localVarPath = `/v1.0/ais_track/{mmsi}`
                .replace(`{${"mmsi"}}`, encodeURIComponent(String(mmsi)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (start !== undefined) {
                localVarQueryParameter['start'] = (start as any instanceof Date) ?
                    (start as any).toISOString() :
                    start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = (end as any instanceof Date) ?
                    (end as any).toISOString() :
                    end;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * V1aisApi - functional programming interface
 * @export
 */
export const V1aisApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = V1aisApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} mmsi 
         * @param {string} [start] 
         * @param {string} [end] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async aisTrack(mmsi: number, start?: string, end?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AisPosition>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.aisTrack(mmsi, start, end, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * V1aisApi - factory interface
 * @export
 */
export const V1aisApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = V1aisApiFp(configuration)
    return {
        /**
         * 
         * @param {V1aisApiAisTrackRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aisTrack(requestParameters: V1aisApiAisTrackRequest, options?: AxiosRequestConfig): AxiosPromise<Array<AisPosition>> {
            return localVarFp.aisTrack(requestParameters.mmsi, requestParameters.start, requestParameters.end, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for aisTrack operation in V1aisApi.
 * @export
 * @interface V1aisApiAisTrackRequest
 */
export interface V1aisApiAisTrackRequest {
    /**
     * 
     * @type {number}
     * @memberof V1aisApiAisTrack
     */
    readonly mmsi: number

    /**
     * 
     * @type {string}
     * @memberof V1aisApiAisTrack
     */
    readonly start?: string

    /**
     * 
     * @type {string}
     * @memberof V1aisApiAisTrack
     */
    readonly end?: string
}

/**
 * V1aisApi - object-oriented interface
 * @export
 * @class V1aisApi
 * @extends {BaseAPI}
 */
export class V1aisApi extends BaseAPI {
    /**
     * 
     * @param {V1aisApiAisTrackRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1aisApi
     */
    public aisTrack(requestParameters: V1aisApiAisTrackRequest, options?: AxiosRequestConfig) {
        return V1aisApiFp(this.configuration).aisTrack(requestParameters.mmsi, requestParameters.start, requestParameters.end, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * V1aisVmsApi - axios parameter creator
 * @export
 */
export const V1aisVmsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} [mmsi] 
         * @param {string} [callSign] 
         * @param {string} [start] 
         * @param {string} [end] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aisVmsPositions: async (mmsi?: number, callSign?: string, start?: string, end?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1.0/ais_vms_positions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (mmsi !== undefined) {
                localVarQueryParameter['mmsi'] = mmsi;
            }

            if (callSign !== undefined) {
                localVarQueryParameter['callSign'] = callSign;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = (start as any instanceof Date) ?
                    (start as any).toISOString() :
                    start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = (end as any instanceof Date) ?
                    (end as any).toISOString() :
                    end;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * V1aisVmsApi - functional programming interface
 * @export
 */
export const V1aisVmsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = V1aisVmsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} [mmsi] 
         * @param {string} [callSign] 
         * @param {string} [start] 
         * @param {string} [end] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async aisVmsPositions(mmsi?: number, callSign?: string, start?: string, end?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AisVmsPosition>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.aisVmsPositions(mmsi, callSign, start, end, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * V1aisVmsApi - factory interface
 * @export
 */
export const V1aisVmsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = V1aisVmsApiFp(configuration)
    return {
        /**
         * 
         * @param {V1aisVmsApiAisVmsPositionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aisVmsPositions(requestParameters: V1aisVmsApiAisVmsPositionsRequest = {}, options?: AxiosRequestConfig): AxiosPromise<Array<AisVmsPosition>> {
            return localVarFp.aisVmsPositions(requestParameters.mmsi, requestParameters.callSign, requestParameters.start, requestParameters.end, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for aisVmsPositions operation in V1aisVmsApi.
 * @export
 * @interface V1aisVmsApiAisVmsPositionsRequest
 */
export interface V1aisVmsApiAisVmsPositionsRequest {
    /**
     * 
     * @type {number}
     * @memberof V1aisVmsApiAisVmsPositions
     */
    readonly mmsi?: number

    /**
     * 
     * @type {string}
     * @memberof V1aisVmsApiAisVmsPositions
     */
    readonly callSign?: string

    /**
     * 
     * @type {string}
     * @memberof V1aisVmsApiAisVmsPositions
     */
    readonly start?: string

    /**
     * 
     * @type {string}
     * @memberof V1aisVmsApiAisVmsPositions
     */
    readonly end?: string
}

/**
 * V1aisVmsApi - object-oriented interface
 * @export
 * @class V1aisVmsApi
 * @extends {BaseAPI}
 */
export class V1aisVmsApi extends BaseAPI {
    /**
     * 
     * @param {V1aisVmsApiAisVmsPositionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1aisVmsApi
     */
    public aisVmsPositions(requestParameters: V1aisVmsApiAisVmsPositionsRequest = {}, options?: AxiosRequestConfig) {
        return V1aisVmsApiFp(this.configuration).aisVmsPositions(requestParameters.mmsi, requestParameters.callSign, requestParameters.start, requestParameters.end, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * V1fishingFacilityApi - axios parameter creator
 * @export
 */
export const V1fishingFacilityApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [mmsis] 
         * @param {string} [callSigns] 
         * @param {string} [toolTypes] 
         * @param {boolean} [active] 
         * @param {string} [setupRanges] 
         * @param {string} [removedRanges] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fishingFacilities: async (mmsis?: string, callSigns?: string, toolTypes?: string, active?: boolean, setupRanges?: string, removedRanges?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1.0/fishing_facilities`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (mmsis !== undefined) {
                localVarQueryParameter['mmsis'] = mmsis;
            }

            if (callSigns !== undefined) {
                localVarQueryParameter['callSigns'] = callSigns;
            }

            if (toolTypes !== undefined) {
                localVarQueryParameter['toolTypes'] = toolTypes;
            }

            if (active !== undefined) {
                localVarQueryParameter['active'] = active;
            }

            if (setupRanges !== undefined) {
                localVarQueryParameter['setupRanges'] = setupRanges;
            }

            if (removedRanges !== undefined) {
                localVarQueryParameter['removedRanges'] = removedRanges;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * V1fishingFacilityApi - functional programming interface
 * @export
 */
export const V1fishingFacilityApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = V1fishingFacilityApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} [mmsis] 
         * @param {string} [callSigns] 
         * @param {string} [toolTypes] 
         * @param {boolean} [active] 
         * @param {string} [setupRanges] 
         * @param {string} [removedRanges] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fishingFacilities(mmsis?: string, callSigns?: string, toolTypes?: string, active?: boolean, setupRanges?: string, removedRanges?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FishingFacility>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fishingFacilities(mmsis, callSigns, toolTypes, active, setupRanges, removedRanges, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * V1fishingFacilityApi - factory interface
 * @export
 */
export const V1fishingFacilityApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = V1fishingFacilityApiFp(configuration)
    return {
        /**
         * 
         * @param {V1fishingFacilityApiFishingFacilitiesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fishingFacilities(requestParameters: V1fishingFacilityApiFishingFacilitiesRequest = {}, options?: AxiosRequestConfig): AxiosPromise<Array<FishingFacility>> {
            return localVarFp.fishingFacilities(requestParameters.mmsis, requestParameters.callSigns, requestParameters.toolTypes, requestParameters.active, requestParameters.setupRanges, requestParameters.removedRanges, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for fishingFacilities operation in V1fishingFacilityApi.
 * @export
 * @interface V1fishingFacilityApiFishingFacilitiesRequest
 */
export interface V1fishingFacilityApiFishingFacilitiesRequest {
    /**
     * 
     * @type {string}
     * @memberof V1fishingFacilityApiFishingFacilities
     */
    readonly mmsis?: string

    /**
     * 
     * @type {string}
     * @memberof V1fishingFacilityApiFishingFacilities
     */
    readonly callSigns?: string

    /**
     * 
     * @type {string}
     * @memberof V1fishingFacilityApiFishingFacilities
     */
    readonly toolTypes?: string

    /**
     * 
     * @type {boolean}
     * @memberof V1fishingFacilityApiFishingFacilities
     */
    readonly active?: boolean

    /**
     * 
     * @type {string}
     * @memberof V1fishingFacilityApiFishingFacilities
     */
    readonly setupRanges?: string

    /**
     * 
     * @type {string}
     * @memberof V1fishingFacilityApiFishingFacilities
     */
    readonly removedRanges?: string
}

/**
 * V1fishingFacilityApi - object-oriented interface
 * @export
 * @class V1fishingFacilityApi
 * @extends {BaseAPI}
 */
export class V1fishingFacilityApi extends BaseAPI {
    /**
     * 
     * @param {V1fishingFacilityApiFishingFacilitiesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1fishingFacilityApi
     */
    public fishingFacilities(requestParameters: V1fishingFacilityApiFishingFacilitiesRequest = {}, options?: AxiosRequestConfig) {
        return V1fishingFacilityApiFp(this.configuration).fishingFacilities(requestParameters.mmsis, requestParameters.callSigns, requestParameters.toolTypes, requestParameters.active, requestParameters.setupRanges, requestParameters.removedRanges, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * V1gearApi - axios parameter creator
 * @export
 */
export const V1gearApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gear: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1.0/gear`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gearGroups: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1.0/gear_groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gearMainGroups: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1.0/gear_main_groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * V1gearApi - functional programming interface
 * @export
 */
export const V1gearApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = V1gearApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gear(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Gear>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gear(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gearGroups(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GearGroup>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gearGroups(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gearMainGroups(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GearMainGroup>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gearMainGroups(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * V1gearApi - factory interface
 * @export
 */
export const V1gearApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = V1gearApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gear(options?: AxiosRequestConfig): AxiosPromise<Array<Gear>> {
            return localVarFp.gear(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gearGroups(options?: AxiosRequestConfig): AxiosPromise<Array<GearGroup>> {
            return localVarFp.gearGroups(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gearMainGroups(options?: AxiosRequestConfig): AxiosPromise<Array<GearMainGroup>> {
            return localVarFp.gearMainGroups(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * V1gearApi - object-oriented interface
 * @export
 * @class V1gearApi
 * @extends {BaseAPI}
 */
export class V1gearApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1gearApi
     */
    public gear(options?: AxiosRequestConfig) {
        return V1gearApiFp(this.configuration).gear(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1gearApi
     */
    public gearGroups(options?: AxiosRequestConfig) {
        return V1gearApiFp(this.configuration).gearGroups(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1gearApi
     */
    public gearMainGroups(options?: AxiosRequestConfig) {
        return V1gearApiFp(this.configuration).gearMainGroups(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * V1haulApi - axios parameter creator
 * @export
 */
export const V1haulApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [months] 
         * @param {string} [catchLocations] 
         * @param {string} [gearGroupIds] 
         * @param {string} [speciesGroupIds] 
         * @param {string} [vesselLengthRanges] 
         * @param {string} [fiskeridirVesselIds] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hauls: async (months?: string, catchLocations?: string, gearGroupIds?: string, speciesGroupIds?: string, vesselLengthRanges?: string, fiskeridirVesselIds?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1.0/hauls`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (months !== undefined) {
                localVarQueryParameter['months'] = months;
            }

            if (catchLocations !== undefined) {
                localVarQueryParameter['catchLocations'] = catchLocations;
            }

            if (gearGroupIds !== undefined) {
                localVarQueryParameter['gearGroupIds'] = gearGroupIds;
            }

            if (speciesGroupIds !== undefined) {
                localVarQueryParameter['speciesGroupIds'] = speciesGroupIds;
            }

            if (vesselLengthRanges !== undefined) {
                localVarQueryParameter['vesselLengthRanges'] = vesselLengthRanges;
            }

            if (fiskeridirVesselIds !== undefined) {
                localVarQueryParameter['fiskeridirVesselIds'] = fiskeridirVesselIds;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ActiveHaulsFilter} activeFilter What feature to group by on the y-axis of the output matrices
         * @param {string} [months] 
         * @param {string} [catchLocations] 
         * @param {string} [gearGroupIds] 
         * @param {string} [speciesGroupIds] 
         * @param {string} [vesselLengthGroups] 
         * @param {string} [fiskeridirVesselIds] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        haulsMatrix: async (activeFilter: ActiveHaulsFilter, months?: string, catchLocations?: string, gearGroupIds?: string, speciesGroupIds?: string, vesselLengthGroups?: string, fiskeridirVesselIds?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'activeFilter' is not null or undefined
            assertParamExists('haulsMatrix', 'activeFilter', activeFilter)
            const localVarPath = `/v1.0/hauls_matrix/{active_filter}`
                .replace(`{${"active_filter"}}`, encodeURIComponent(String(activeFilter)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (months !== undefined) {
                localVarQueryParameter['months'] = months;
            }

            if (catchLocations !== undefined) {
                localVarQueryParameter['catchLocations'] = catchLocations;
            }

            if (gearGroupIds !== undefined) {
                localVarQueryParameter['gearGroupIds'] = gearGroupIds;
            }

            if (speciesGroupIds !== undefined) {
                localVarQueryParameter['speciesGroupIds'] = speciesGroupIds;
            }

            if (vesselLengthGroups !== undefined) {
                localVarQueryParameter['vesselLengthGroups'] = vesselLengthGroups;
            }

            if (fiskeridirVesselIds !== undefined) {
                localVarQueryParameter['fiskeridirVesselIds'] = fiskeridirVesselIds;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * V1haulApi - functional programming interface
 * @export
 */
export const V1haulApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = V1haulApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} [months] 
         * @param {string} [catchLocations] 
         * @param {string} [gearGroupIds] 
         * @param {string} [speciesGroupIds] 
         * @param {string} [vesselLengthRanges] 
         * @param {string} [fiskeridirVesselIds] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async hauls(months?: string, catchLocations?: string, gearGroupIds?: string, speciesGroupIds?: string, vesselLengthRanges?: string, fiskeridirVesselIds?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Haul>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.hauls(months, catchLocations, gearGroupIds, speciesGroupIds, vesselLengthRanges, fiskeridirVesselIds, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {ActiveHaulsFilter} activeFilter What feature to group by on the y-axis of the output matrices
         * @param {string} [months] 
         * @param {string} [catchLocations] 
         * @param {string} [gearGroupIds] 
         * @param {string} [speciesGroupIds] 
         * @param {string} [vesselLengthGroups] 
         * @param {string} [fiskeridirVesselIds] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async haulsMatrix(activeFilter: ActiveHaulsFilter, months?: string, catchLocations?: string, gearGroupIds?: string, speciesGroupIds?: string, vesselLengthGroups?: string, fiskeridirVesselIds?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HaulsMatrix>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.haulsMatrix(activeFilter, months, catchLocations, gearGroupIds, speciesGroupIds, vesselLengthGroups, fiskeridirVesselIds, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * V1haulApi - factory interface
 * @export
 */
export const V1haulApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = V1haulApiFp(configuration)
    return {
        /**
         * 
         * @param {V1haulApiHaulsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hauls(requestParameters: V1haulApiHaulsRequest = {}, options?: AxiosRequestConfig): AxiosPromise<Array<Haul>> {
            return localVarFp.hauls(requestParameters.months, requestParameters.catchLocations, requestParameters.gearGroupIds, requestParameters.speciesGroupIds, requestParameters.vesselLengthRanges, requestParameters.fiskeridirVesselIds, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {V1haulApiHaulsMatrixRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        haulsMatrix(requestParameters: V1haulApiHaulsMatrixRequest, options?: AxiosRequestConfig): AxiosPromise<HaulsMatrix> {
            return localVarFp.haulsMatrix(requestParameters.activeFilter, requestParameters.months, requestParameters.catchLocations, requestParameters.gearGroupIds, requestParameters.speciesGroupIds, requestParameters.vesselLengthGroups, requestParameters.fiskeridirVesselIds, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for hauls operation in V1haulApi.
 * @export
 * @interface V1haulApiHaulsRequest
 */
export interface V1haulApiHaulsRequest {
    /**
     * 
     * @type {string}
     * @memberof V1haulApiHauls
     */
    readonly months?: string

    /**
     * 
     * @type {string}
     * @memberof V1haulApiHauls
     */
    readonly catchLocations?: string

    /**
     * 
     * @type {string}
     * @memberof V1haulApiHauls
     */
    readonly gearGroupIds?: string

    /**
     * 
     * @type {string}
     * @memberof V1haulApiHauls
     */
    readonly speciesGroupIds?: string

    /**
     * 
     * @type {string}
     * @memberof V1haulApiHauls
     */
    readonly vesselLengthRanges?: string

    /**
     * 
     * @type {string}
     * @memberof V1haulApiHauls
     */
    readonly fiskeridirVesselIds?: string
}

/**
 * Request parameters for haulsMatrix operation in V1haulApi.
 * @export
 * @interface V1haulApiHaulsMatrixRequest
 */
export interface V1haulApiHaulsMatrixRequest {
    /**
     * What feature to group by on the y-axis of the output matrices
     * @type {ActiveHaulsFilter}
     * @memberof V1haulApiHaulsMatrix
     */
    readonly activeFilter: ActiveHaulsFilter

    /**
     * 
     * @type {string}
     * @memberof V1haulApiHaulsMatrix
     */
    readonly months?: string

    /**
     * 
     * @type {string}
     * @memberof V1haulApiHaulsMatrix
     */
    readonly catchLocations?: string

    /**
     * 
     * @type {string}
     * @memberof V1haulApiHaulsMatrix
     */
    readonly gearGroupIds?: string

    /**
     * 
     * @type {string}
     * @memberof V1haulApiHaulsMatrix
     */
    readonly speciesGroupIds?: string

    /**
     * 
     * @type {string}
     * @memberof V1haulApiHaulsMatrix
     */
    readonly vesselLengthGroups?: string

    /**
     * 
     * @type {string}
     * @memberof V1haulApiHaulsMatrix
     */
    readonly fiskeridirVesselIds?: string
}

/**
 * V1haulApi - object-oriented interface
 * @export
 * @class V1haulApi
 * @extends {BaseAPI}
 */
export class V1haulApi extends BaseAPI {
    /**
     * 
     * @param {V1haulApiHaulsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1haulApi
     */
    public hauls(requestParameters: V1haulApiHaulsRequest = {}, options?: AxiosRequestConfig) {
        return V1haulApiFp(this.configuration).hauls(requestParameters.months, requestParameters.catchLocations, requestParameters.gearGroupIds, requestParameters.speciesGroupIds, requestParameters.vesselLengthRanges, requestParameters.fiskeridirVesselIds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {V1haulApiHaulsMatrixRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1haulApi
     */
    public haulsMatrix(requestParameters: V1haulApiHaulsMatrixRequest, options?: AxiosRequestConfig) {
        return V1haulApiFp(this.configuration).haulsMatrix(requestParameters.activeFilter, requestParameters.months, requestParameters.catchLocations, requestParameters.gearGroupIds, requestParameters.speciesGroupIds, requestParameters.vesselLengthGroups, requestParameters.fiskeridirVesselIds, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * V1speciesApi - axios parameter creator
 * @export
 */
export const V1speciesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        species: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1.0/species`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        speciesFao: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1.0/species_fao`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        speciesFiskeridir: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1.0/species_fiskeridir`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        speciesGroups: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1.0/species_groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        speciesMainGroups: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1.0/species_main_groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * V1speciesApi - functional programming interface
 * @export
 */
export const V1speciesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = V1speciesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async species(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Species>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.species(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async speciesFao(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SpeciesFao>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.speciesFao(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async speciesFiskeridir(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SpeciesFiskeridir>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.speciesFiskeridir(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async speciesGroups(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SpeciesGroup>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.speciesGroups(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async speciesMainGroups(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SpeciesMainGroup>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.speciesMainGroups(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * V1speciesApi - factory interface
 * @export
 */
export const V1speciesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = V1speciesApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        species(options?: AxiosRequestConfig): AxiosPromise<Array<Species>> {
            return localVarFp.species(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        speciesFao(options?: AxiosRequestConfig): AxiosPromise<Array<SpeciesFao>> {
            return localVarFp.speciesFao(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        speciesFiskeridir(options?: AxiosRequestConfig): AxiosPromise<Array<SpeciesFiskeridir>> {
            return localVarFp.speciesFiskeridir(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        speciesGroups(options?: AxiosRequestConfig): AxiosPromise<Array<SpeciesGroup>> {
            return localVarFp.speciesGroups(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        speciesMainGroups(options?: AxiosRequestConfig): AxiosPromise<Array<SpeciesMainGroup>> {
            return localVarFp.speciesMainGroups(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * V1speciesApi - object-oriented interface
 * @export
 * @class V1speciesApi
 * @extends {BaseAPI}
 */
export class V1speciesApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1speciesApi
     */
    public species(options?: AxiosRequestConfig) {
        return V1speciesApiFp(this.configuration).species(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1speciesApi
     */
    public speciesFao(options?: AxiosRequestConfig) {
        return V1speciesApiFp(this.configuration).speciesFao(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1speciesApi
     */
    public speciesFiskeridir(options?: AxiosRequestConfig) {
        return V1speciesApiFp(this.configuration).speciesFiskeridir(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1speciesApi
     */
    public speciesGroups(options?: AxiosRequestConfig) {
        return V1speciesApiFp(this.configuration).speciesGroups(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1speciesApi
     */
    public speciesMainGroups(options?: AxiosRequestConfig) {
        return V1speciesApiFp(this.configuration).speciesMainGroups(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * V1tripApi - axios parameter creator
 * @export
 */
export const V1tripApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} haulId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tripOfHaul: async (haulId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'haulId' is not null or undefined
            assertParamExists('tripOfHaul', 'haulId', haulId)
            const localVarPath = `/v1.0/trip_of_haul/{haul_id}`
                .replace(`{${"haul_id"}}`, encodeURIComponent(String(haulId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} fiskeridirVesselId 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {Ordering} [ordering] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trips: async (fiskeridirVesselId: number, limit?: number, offset?: number, ordering?: Ordering, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fiskeridirVesselId' is not null or undefined
            assertParamExists('trips', 'fiskeridirVesselId', fiskeridirVesselId)
            const localVarPath = `/v1.0/trips/{fiskeridir_vessel_id}`
                .replace(`{${"fiskeridir_vessel_id"}}`, encodeURIComponent(String(fiskeridirVesselId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * V1tripApi - functional programming interface
 * @export
 */
export const V1tripApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = V1tripApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} haulId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tripOfHaul(haulId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Trip>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tripOfHaul(haulId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} fiskeridirVesselId 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {Ordering} [ordering] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trips(fiskeridirVesselId: number, limit?: number, offset?: number, ordering?: Ordering, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Trip>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trips(fiskeridirVesselId, limit, offset, ordering, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * V1tripApi - factory interface
 * @export
 */
export const V1tripApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = V1tripApiFp(configuration)
    return {
        /**
         * 
         * @param {V1tripApiTripOfHaulRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tripOfHaul(requestParameters: V1tripApiTripOfHaulRequest, options?: AxiosRequestConfig): AxiosPromise<Trip> {
            return localVarFp.tripOfHaul(requestParameters.haulId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {V1tripApiTripsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trips(requestParameters: V1tripApiTripsRequest, options?: AxiosRequestConfig): AxiosPromise<Array<Trip>> {
            return localVarFp.trips(requestParameters.fiskeridirVesselId, requestParameters.limit, requestParameters.offset, requestParameters.ordering, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for tripOfHaul operation in V1tripApi.
 * @export
 * @interface V1tripApiTripOfHaulRequest
 */
export interface V1tripApiTripOfHaulRequest {
    /**
     * 
     * @type {string}
     * @memberof V1tripApiTripOfHaul
     */
    readonly haulId: string
}

/**
 * Request parameters for trips operation in V1tripApi.
 * @export
 * @interface V1tripApiTripsRequest
 */
export interface V1tripApiTripsRequest {
    /**
     * 
     * @type {number}
     * @memberof V1tripApiTrips
     */
    readonly fiskeridirVesselId: number

    /**
     * 
     * @type {number}
     * @memberof V1tripApiTrips
     */
    readonly limit?: number

    /**
     * 
     * @type {number}
     * @memberof V1tripApiTrips
     */
    readonly offset?: number

    /**
     * 
     * @type {Ordering}
     * @memberof V1tripApiTrips
     */
    readonly ordering?: Ordering
}

/**
 * V1tripApi - object-oriented interface
 * @export
 * @class V1tripApi
 * @extends {BaseAPI}
 */
export class V1tripApi extends BaseAPI {
    /**
     * 
     * @param {V1tripApiTripOfHaulRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1tripApi
     */
    public tripOfHaul(requestParameters: V1tripApiTripOfHaulRequest, options?: AxiosRequestConfig) {
        return V1tripApiFp(this.configuration).tripOfHaul(requestParameters.haulId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {V1tripApiTripsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1tripApi
     */
    public trips(requestParameters: V1tripApiTripsRequest, options?: AxiosRequestConfig) {
        return V1tripApiFp(this.configuration).trips(requestParameters.fiskeridirVesselId, requestParameters.limit, requestParameters.offset, requestParameters.ordering, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * V1vesselApi - axios parameter creator
 * @export
 */
export const V1vesselApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vessels: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1.0/vessels`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * V1vesselApi - functional programming interface
 * @export
 */
export const V1vesselApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = V1vesselApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async vessels(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Vessel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.vessels(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * V1vesselApi - factory interface
 * @export
 */
export const V1vesselApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = V1vesselApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vessels(options?: AxiosRequestConfig): AxiosPromise<Array<Vessel>> {
            return localVarFp.vessels(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * V1vesselApi - object-oriented interface
 * @export
 * @class V1vesselApi
 * @extends {BaseAPI}
 */
export class V1vesselApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1vesselApi
     */
    public vessels(options?: AxiosRequestConfig) {
        return V1vesselApiFp(this.configuration).vessels(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * V1vmsApi - axios parameter creator
 * @export
 */
export const V1vmsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} callSign 
         * @param {string} [start] 
         * @param {string} [end] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vmsPositions: async (callSign: string, start?: string, end?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'callSign' is not null or undefined
            assertParamExists('vmsPositions', 'callSign', callSign)
            const localVarPath = `/v1.0/vms/{call_sign}`
                .replace(`{${"call_sign"}}`, encodeURIComponent(String(callSign)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (start !== undefined) {
                localVarQueryParameter['start'] = (start as any instanceof Date) ?
                    (start as any).toISOString() :
                    start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = (end as any instanceof Date) ?
                    (end as any).toISOString() :
                    end;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * V1vmsApi - functional programming interface
 * @export
 */
export const V1vmsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = V1vmsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} callSign 
         * @param {string} [start] 
         * @param {string} [end] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async vmsPositions(callSign: string, start?: string, end?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<VmsPosition>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.vmsPositions(callSign, start, end, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * V1vmsApi - factory interface
 * @export
 */
export const V1vmsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = V1vmsApiFp(configuration)
    return {
        /**
         * 
         * @param {V1vmsApiVmsPositionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vmsPositions(requestParameters: V1vmsApiVmsPositionsRequest, options?: AxiosRequestConfig): AxiosPromise<Array<VmsPosition>> {
            return localVarFp.vmsPositions(requestParameters.callSign, requestParameters.start, requestParameters.end, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for vmsPositions operation in V1vmsApi.
 * @export
 * @interface V1vmsApiVmsPositionsRequest
 */
export interface V1vmsApiVmsPositionsRequest {
    /**
     * 
     * @type {string}
     * @memberof V1vmsApiVmsPositions
     */
    readonly callSign: string

    /**
     * 
     * @type {string}
     * @memberof V1vmsApiVmsPositions
     */
    readonly start?: string

    /**
     * 
     * @type {string}
     * @memberof V1vmsApiVmsPositions
     */
    readonly end?: string
}

/**
 * V1vmsApi - object-oriented interface
 * @export
 * @class V1vmsApi
 * @extends {BaseAPI}
 */
export class V1vmsApi extends BaseAPI {
    /**
     * 
     * @param {V1vmsApiVmsPositionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1vmsApi
     */
    public vmsPositions(requestParameters: V1vmsApiVmsPositionsRequest, options?: AxiosRequestConfig) {
        return V1vmsApiFp(this.configuration).vmsPositions(requestParameters.callSign, requestParameters.start, requestParameters.end, options).then((request) => request(this.axios, this.basePath));
    }
}


