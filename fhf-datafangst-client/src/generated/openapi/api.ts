/* tslint:disable */
/* eslint-disable */
/**
 * web-api
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1.0
 * Contact: contact@orcalabs.no
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @enum {string}
 */

export const ActiveHaulsFilter = {
    Date: 'date',
    GearGroup: 'gearGroup',
    SpeciesGroup: 'speciesGroup',
    VesselLength: 'vesselLength'
} as const;

export type ActiveHaulsFilter = typeof ActiveHaulsFilter[keyof typeof ActiveHaulsFilter];


/**
 * 
 * @export
 * @enum {string}
 */

export const ActiveLandingFilter = {
    Date: 'date',
    GearGroup: 'gearGroup',
    SpeciesGroup: 'speciesGroup',
    VesselLength: 'vesselLength'
} as const;

export type ActiveLandingFilter = typeof ActiveLandingFilter[keyof typeof ActiveLandingFilter];


/**
 * 
 * @export
 * @interface AisPosition
 */
export interface AisPosition {
    /**
     * 
     * @type {number}
     * @memberof AisPosition
     */
    'cog'?: number | null;
    /**
     * 
     * @type {AisPositionDetails}
     * @memberof AisPosition
     */
    'det'?: AisPositionDetails | null;
    /**
     * 
     * @type {number}
     * @memberof AisPosition
     */
    'lat': number;
    /**
     * 
     * @type {number}
     * @memberof AisPosition
     */
    'lon': number;
    /**
     * 
     * @type {string}
     * @memberof AisPosition
     */
    'timestamp': string;
}
/**
 * 
 * @export
 * @interface AisPositionDetails
 */
export interface AisPositionDetails {
    /**
     * 
     * @type {number}
     * @memberof AisPositionDetails
     */
    'distanceToShore': number;
    /**
     * 
     * @type {boolean}
     * @memberof AisPositionDetails
     */
    'missingData': boolean;
    /**
     * 
     * @type {NavigationStatus}
     * @memberof AisPositionDetails
     */
    'navigationalStatus'?: NavigationStatus | null;
    /**
     * 
     * @type {number}
     * @memberof AisPositionDetails
     */
    'rateOfTurn'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof AisPositionDetails
     */
    'speedOverGround'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof AisPositionDetails
     */
    'trueHeading'?: number | null;
}
/**
 * 
 * @export
 * @interface AisVessel
 */
export interface AisVessel {
    /**
     * 
     * @type {string}
     * @memberof AisVessel
     */
    'callSign'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AisVessel
     */
    'destination'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AisVessel
     */
    'eta'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof AisVessel
     */
    'imoNumber'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof AisVessel
     */
    'mmsi': number;
    /**
     * 
     * @type {string}
     * @memberof AisVessel
     */
    'name'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof AisVessel
     */
    'shipLength'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof AisVessel
     */
    'shipWidth'?: number | null;
}
/**
 * 
 * @export
 * @interface AisVmsPosition
 */
export interface AisVmsPosition {
    /**
     * 
     * @type {number}
     * @memberof AisVmsPosition
     */
    'cog'?: number | null;
    /**
     * 
     * @type {AisVmsPositionDetails}
     * @memberof AisVmsPosition
     */
    'det'?: AisVmsPositionDetails | null;
    /**
     * 
     * @type {number}
     * @memberof AisVmsPosition
     */
    'lat': number;
    /**
     * 
     * @type {number}
     * @memberof AisVmsPosition
     */
    'lon': number;
    /**
     * 
     * @type {number}
     * @memberof AisVmsPosition
     */
    'speed'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof AisVmsPosition
     */
    'timestamp': string;
}
/**
 * 
 * @export
 * @interface AisVmsPositionDetails
 */
export interface AisVmsPositionDetails {
    /**
     * 
     * @type {number}
     * @memberof AisVmsPositionDetails
     */
    'distanceToShore'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof AisVmsPositionDetails
     */
    'missingData': boolean;
    /**
     * 
     * @type {NavigationStatus}
     * @memberof AisVmsPositionDetails
     */
    'navigationalStatus'?: NavigationStatus | null;
    /**
     * 
     * @type {number}
     * @memberof AisVmsPositionDetails
     */
    'rateOfTurn'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof AisVmsPositionDetails
     */
    'trueHeading'?: number | null;
}
/**
 * @type ApiError
 * @export
 */
export type ApiError = ApiErrorOneOf | ApiErrorOneOf1 | ApiErrorOneOf2 | ApiErrorOneOf3 | ApiErrorOneOf4 | ApiErrorOneOf5 | ApiErrorOneOf6 | ApiErrorOneOf7 | ApiErrorOneOf8;

/**
 * 
 * @export
 * @interface ApiErrorOneOf
 */
export interface ApiErrorOneOf {
    /**
     * 
     * @type {ApiErrorOneOfStartAfterEnd}
     * @memberof ApiErrorOneOf
     */
    'StartAfterEnd': ApiErrorOneOfStartAfterEnd;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ApiErrorOneOf1 = {
    InvalidCallSign: 'InvalidCallSign'
} as const;

export type ApiErrorOneOf1 = typeof ApiErrorOneOf1[keyof typeof ApiErrorOneOf1];


/**
 * 
 * @export
 * @enum {string}
 */

export const ApiErrorOneOf2 = {
    InvalidDateRange: 'InvalidDateRange'
} as const;

export type ApiErrorOneOf2 = typeof ApiErrorOneOf2[keyof typeof ApiErrorOneOf2];


/**
 * 
 * @export
 * @enum {string}
 */

export const ApiErrorOneOf3 = {
    InternalServerError: 'InternalServerError'
} as const;

export type ApiErrorOneOf3 = typeof ApiErrorOneOf3[keyof typeof ApiErrorOneOf3];


/**
 * 
 * @export
 * @enum {string}
 */

export const ApiErrorOneOf4 = {
    MissingMmsiOrCallSign: 'MissingMmsiOrCallSign'
} as const;

export type ApiErrorOneOf4 = typeof ApiErrorOneOf4[keyof typeof ApiErrorOneOf4];


/**
 * 
 * @export
 * @enum {string}
 */

export const ApiErrorOneOf5 = {
    Forbidden: 'Forbidden'
} as const;

export type ApiErrorOneOf5 = typeof ApiErrorOneOf5[keyof typeof ApiErrorOneOf5];


/**
 * 
 * @export
 * @enum {string}
 */

export const ApiErrorOneOf6 = {
    MissingBwToken: 'MissingBwToken'
} as const;

export type ApiErrorOneOf6 = typeof ApiErrorOneOf6[keyof typeof ApiErrorOneOf6];


/**
 * 
 * @export
 * @enum {string}
 */

export const ApiErrorOneOf7 = {
    InvalidBwToken: 'InvalidBwToken'
} as const;

export type ApiErrorOneOf7 = typeof ApiErrorOneOf7[keyof typeof ApiErrorOneOf7];


/**
 * 
 * @export
 * @enum {string}
 */

export const ApiErrorOneOf8 = {
    InvalidLandingId: 'InvalidLandingId'
} as const;

export type ApiErrorOneOf8 = typeof ApiErrorOneOf8[keyof typeof ApiErrorOneOf8];


/**
 * 
 * @export
 * @interface ApiErrorOneOfStartAfterEnd
 */
export interface ApiErrorOneOfStartAfterEnd {
    /**
     * 
     * @type {string}
     * @memberof ApiErrorOneOfStartAfterEnd
     */
    'end': string;
    /**
     * 
     * @type {string}
     * @memberof ApiErrorOneOfStartAfterEnd
     */
    'start': string;
}
/**
 * 
 * @export
 * @interface Catch
 */
export interface Catch {
    /**
     * 
     * @type {number}
     * @memberof Catch
     */
    'grossWeight': number;
    /**
     * 
     * @type {number}
     * @memberof Catch
     */
    'livingWeight': number;
    /**
     * 
     * @type {number}
     * @memberof Catch
     */
    'productQualityId': number;
    /**
     * 
     * @type {string}
     * @memberof Catch
     */
    'productQualityName': string;
    /**
     * 
     * @type {number}
     * @memberof Catch
     */
    'productWeight': number;
    /**
     * 
     * @type {number}
     * @memberof Catch
     */
    'speciesFiskeridirId': number;
}
/**
 * 
 * @export
 * @interface CurrentTrip
 */
export interface CurrentTrip {
    /**
     * 
     * @type {string}
     * @memberof CurrentTrip
     */
    'departure': string;
    /**
     * 
     * @type {Array<FishingFacility>}
     * @memberof CurrentTrip
     */
    'fishingFacilities': Array<FishingFacility>;
    /**
     * 
     * @type {Array<Haul>}
     * @memberof CurrentTrip
     */
    'hauls': Array<Haul>;
    /**
     * 
     * @type {number}
     * @memberof CurrentTrip
     */
    'targetSpeciesFiskeridirId'?: number | null;
}
/**
 * 
 * @export
 * @interface Delivery
 */
export interface Delivery {
    /**
     * 
     * @type {Array<Catch>}
     * @memberof Delivery
     */
    'delivered': Array<Catch>;
    /**
     * 
     * @type {number}
     * @memberof Delivery
     */
    'totalGrossWeight': number;
    /**
     * 
     * @type {number}
     * @memberof Delivery
     */
    'totalLivingWeight': number;
    /**
     * 
     * @type {number}
     * @memberof Delivery
     */
    'totalProductWeight': number;
}
/**
 * 
 * @export
 * @interface DeliveryPoint
 */
export interface DeliveryPoint {
    /**
     * 
     * @type {string}
     * @memberof DeliveryPoint
     */
    'address'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DeliveryPoint
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof DeliveryPoint
     */
    'latitude'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof DeliveryPoint
     */
    'longitude'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof DeliveryPoint
     */
    'name'?: string | null;
}
/**
 * 
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
    /**
     * 
     * @type {string}
     * @memberof ErrorResponse
     */
    'description': string;
    /**
     * 
     * @type {ApiError}
     * @memberof ErrorResponse
     */
    'error': ApiError;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const FishingFacilitiesSorting = {
    Setup: 'setup',
    Removed: 'removed',
    LastChanged: 'lastChanged'
} as const;

export type FishingFacilitiesSorting = typeof FishingFacilitiesSorting[keyof typeof FishingFacilitiesSorting];


/**
 * 
 * @export
 * @interface FishingFacility
 */
export interface FishingFacility {
    /**
     * 
     * @type {string}
     * @memberof FishingFacility
     */
    'barentswatchVesselId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FishingFacility
     */
    'callSign'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FishingFacility
     */
    'comment'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FishingFacility
     */
    'contactEmail'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FishingFacility
     */
    'contactPhone'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof FishingFacility
     */
    'fiskeridirVesselId'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof FishingFacility
     */
    'geometryWkt': string;
    /**
     * 
     * @type {number}
     * @memberof FishingFacility
     */
    'imo'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof FishingFacility
     */
    'lastChanged': string;
    /**
     * 
     * @type {number}
     * @memberof FishingFacility
     */
    'mmsi'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof FishingFacility
     */
    'regNum'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FishingFacility
     */
    'removedProcessedTimestamp'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FishingFacility
     */
    'removedTimestamp'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FishingFacility
     */
    'sbrRegNum'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FishingFacility
     */
    'setupProcessedTimestamp'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FishingFacility
     */
    'setupTimestamp': string;
    /**
     * 
     * @type {string}
     * @memberof FishingFacility
     */
    'source'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FishingFacility
     */
    'toolColor'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof FishingFacility
     */
    'toolCount'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof FishingFacility
     */
    'toolId': string;
    /**
     * 
     * @type {number}
     * @memberof FishingFacility
     */
    'toolType': number;
    /**
     * 
     * @type {string}
     * @memberof FishingFacility
     */
    'toolTypeName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FishingFacility
     */
    'vesselName'?: string | null;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const FishingFacilityToolType = {
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_3: 3,
    NUMBER_4: 4,
    NUMBER_5: 5,
    NUMBER_6: 6,
    NUMBER_7: 7,
    NUMBER_8: 8,
    NUMBER_9: 9,
    NUMBER_10: 10,
    NUMBER_11: 11
} as const;

export type FishingFacilityToolType = typeof FishingFacilityToolType[keyof typeof FishingFacilityToolType];


/**
 * 
 * @export
 * @interface FiskeridirVessel
 */
export interface FiskeridirVessel {
    /**
     * 
     * @type {number}
     * @memberof FiskeridirVessel
     */
    'buildingYear'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof FiskeridirVessel
     */
    'callSign': string;
    /**
     * 
     * @type {number}
     * @memberof FiskeridirVessel
     */
    'engineBuildingYear'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof FiskeridirVessel
     */
    'enginePower'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof FiskeridirVessel
     */
    'grossTonnage1969'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof FiskeridirVessel
     */
    'grossTonnageOther'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof FiskeridirVessel
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof FiskeridirVessel
     */
    'length'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof FiskeridirVessel
     */
    'lengthGroupId': number;
    /**
     * 
     * @type {string}
     * @memberof FiskeridirVessel
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FiskeridirVessel
     */
    'nationGroupId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FiskeridirVessel
     */
    'nationId'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof FiskeridirVessel
     */
    'norwegianCountyId'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof FiskeridirVessel
     */
    'norwegianMunicipalityId'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof FiskeridirVessel
     */
    'owner'?: string | null;
    /**
     * 
     * @type {Array<RegisterVesselOwner>}
     * @memberof FiskeridirVessel
     */
    'owners'?: Array<RegisterVesselOwner> | null;
    /**
     * 
     * @type {number}
     * @memberof FiskeridirVessel
     */
    'rebuildingYear'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof FiskeridirVessel
     */
    'registrationId'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof FiskeridirVessel
     */
    'vesselTypeId'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof FiskeridirVessel
     */
    'width'?: number | null;
}
/**
 * 
 * @export
 * @interface Gear
 */
export interface Gear {
    /**
     * 
     * @type {number}
     * @memberof Gear
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof Gear
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface GearGroup
 */
export interface GearGroup {
    /**
     * 
     * @type {number}
     * @memberof GearGroup
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof GearGroup
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface GearMainGroup
 */
export interface GearMainGroup {
    /**
     * 
     * @type {number}
     * @memberof GearMainGroup
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof GearMainGroup
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface Haul
 */
export interface Haul {
    /**
     * 
     * @type {string}
     * @memberof Haul
     */
    'catchLocationStart'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof Haul
     */
    'catchLocations'?: Array<string> | null;
    /**
     * 
     * @type {Array<HaulCatch>}
     * @memberof Haul
     */
    'catches': Array<HaulCatch>;
    /**
     * 
     * @type {number}
     * @memberof Haul
     */
    'duration': number;
    /**
     * 
     * @type {string}
     * @memberof Haul
     */
    'ersActivityId': string;
    /**
     * 
     * @type {number}
     * @memberof Haul
     */
    'fiskeridirVesselId'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof Haul
     */
    'gearGroupId': number;
    /**
     * 
     * @type {number}
     * @memberof Haul
     */
    'gearId': number;
    /**
     * 
     * @type {number}
     * @memberof Haul
     */
    'haulDistance'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof Haul
     */
    'haulId': number;
    /**
     * 
     * @type {number}
     * @memberof Haul
     */
    'oceanDepthEnd': number;
    /**
     * 
     * @type {number}
     * @memberof Haul
     */
    'oceanDepthStart': number;
    /**
     * 
     * @type {number}
     * @memberof Haul
     */
    'quotaTypeId': number;
    /**
     * 
     * @type {number}
     * @memberof Haul
     */
    'startLatitude': number;
    /**
     * 
     * @type {number}
     * @memberof Haul
     */
    'startLongitude': number;
    /**
     * 
     * @type {string}
     * @memberof Haul
     */
    'startTimestamp': string;
    /**
     * 
     * @type {number}
     * @memberof Haul
     */
    'stopLatitude': number;
    /**
     * 
     * @type {number}
     * @memberof Haul
     */
    'stopLongitude': number;
    /**
     * 
     * @type {string}
     * @memberof Haul
     */
    'stopTimestamp': string;
    /**
     * 
     * @type {number}
     * @memberof Haul
     */
    'totalLivingWeight': number;
    /**
     * 
     * @type {string}
     * @memberof Haul
     */
    'vesselCallSign'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Haul
     */
    'vesselCallSignErs': string;
    /**
     * 
     * @type {number}
     * @memberof Haul
     */
    'vesselLength': number;
    /**
     * 
     * @type {number}
     * @memberof Haul
     */
    'vesselLengthGroup': number;
    /**
     * 
     * @type {string}
     * @memberof Haul
     */
    'vesselName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Haul
     */
    'vesselNameErs'?: string | null;
    /**
     * 
     * @type {Array<WhaleCatch>}
     * @memberof Haul
     */
    'whaleCatches': Array<WhaleCatch>;
}
/**
 * 
 * @export
 * @interface HaulCatch
 */
export interface HaulCatch {
    /**
     * 
     * @type {number}
     * @memberof HaulCatch
     */
    'livingWeight': number;
    /**
     * 
     * @type {number}
     * @memberof HaulCatch
     */
    'speciesFiskeridirId': number;
    /**
     * 
     * @type {number}
     * @memberof HaulCatch
     */
    'speciesGroupId': number;
}
/**
 * 
 * @export
 * @interface HaulsMatrix
 */
export interface HaulsMatrix {
    /**
     * 
     * @type {Array<number>}
     * @memberof HaulsMatrix
     */
    'dates': Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof HaulsMatrix
     */
    'gearGroup': Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof HaulsMatrix
     */
    'lengthGroup': Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof HaulsMatrix
     */
    'speciesGroup': Array<number>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const HaulsSorting = {
    StartDate: 'startDate',
    StopDate: 'stopDate',
    Weight: 'weight'
} as const;

export type HaulsSorting = typeof HaulsSorting[keyof typeof HaulsSorting];


/**
 * 
 * @export
 * @interface Landing
 */
export interface Landing {
    /**
     * 
     * @type {string}
     * @memberof Landing
     */
    'catchLocation'?: string | null;
    /**
     * 
     * @type {Array<LandingCatch>}
     * @memberof Landing
     */
    'catches': Array<LandingCatch>;
    /**
     * 
     * @type {string}
     * @memberof Landing
     */
    'deliveryPointId'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Landing
     */
    'fiskeridirVesselId'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof Landing
     */
    'gearGroupId': number;
    /**
     * 
     * @type {number}
     * @memberof Landing
     */
    'gearId': number;
    /**
     * 
     * @type {string}
     * @memberof Landing
     */
    'landingId': string;
    /**
     * 
     * @type {string}
     * @memberof Landing
     */
    'landingTimestamp': string;
    /**
     * 
     * @type {number}
     * @memberof Landing
     */
    'totalGrossWeight': number;
    /**
     * 
     * @type {number}
     * @memberof Landing
     */
    'totalLivingWeight': number;
    /**
     * 
     * @type {number}
     * @memberof Landing
     */
    'totalProductWeight': number;
    /**
     * 
     * @type {string}
     * @memberof Landing
     */
    'vesselCallSign'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Landing
     */
    'vesselLength'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof Landing
     */
    'vesselLengthGroup': number;
    /**
     * 
     * @type {string}
     * @memberof Landing
     */
    'vesselName'?: string | null;
}
/**
 * 
 * @export
 * @interface LandingCatch
 */
export interface LandingCatch {
    /**
     * 
     * @type {number}
     * @memberof LandingCatch
     */
    'grossWeight': number;
    /**
     * 
     * @type {number}
     * @memberof LandingCatch
     */
    'livingWeight': number;
    /**
     * 
     * @type {number}
     * @memberof LandingCatch
     */
    'productWeight': number;
    /**
     * 
     * @type {number}
     * @memberof LandingCatch
     */
    'speciesFiskeridirId': number;
    /**
     * 
     * @type {number}
     * @memberof LandingCatch
     */
    'speciesGroupId': number;
}
/**
 * 
 * @export
 * @interface LandingMatrix
 */
export interface LandingMatrix {
    /**
     * 
     * @type {Array<number>}
     * @memberof LandingMatrix
     */
    'dates': Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof LandingMatrix
     */
    'gearGroup': Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof LandingMatrix
     */
    'lengthGroup': Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof LandingMatrix
     */
    'speciesGroup': Array<number>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const LandingsSorting = {
    LandingTimestamp: 'landingTimestamp',
    LivingWeight: 'livingWeight'
} as const;

export type LandingsSorting = typeof LandingsSorting[keyof typeof LandingsSorting];


/**
 * 
 * @export
 * @enum {string}
 */

export const NavigationStatus = {
    UnderWayUsingEngine: 'UnderWayUsingEngine',
    AtAnchor: 'AtAnchor',
    NotUnderCommand: 'NotUnderCommand',
    RestrictedManoeuverability: 'RestrictedManoeuverability',
    ConstrainedByDraught: 'ConstrainedByDraught',
    Moored: 'Moored',
    Aground: 'Aground',
    EngagedInFishing: 'EngagedInFishing',
    UnderWaySailing: 'UnderWaySailing',
    Reserved9: 'Reserved9',
    Reserved10: 'Reserved10',
    Reserved11: 'Reserved11',
    Reserved12: 'Reserved12',
    Reserved13: 'Reserved13',
    AisSartIsActive: 'AisSartIsActive',
    NotDefined: 'NotDefined'
} as const;

export type NavigationStatus = typeof NavigationStatus[keyof typeof NavigationStatus];


/**
 * 
 * @export
 * @enum {string}
 */

export const Ordering = {
    Asc: 'asc',
    Desc: 'desc'
} as const;

export type Ordering = typeof Ordering[keyof typeof Ordering];


/**
 * 
 * @export
 * @enum {string}
 */

export const RegisterVesselEntityType = {
    Company: 'COMPANY',
    Person: 'PERSON'
} as const;

export type RegisterVesselEntityType = typeof RegisterVesselEntityType[keyof typeof RegisterVesselEntityType];


/**
 * 
 * @export
 * @interface RegisterVesselOwner
 */
export interface RegisterVesselOwner {
    /**
     * 
     * @type {string}
     * @memberof RegisterVesselOwner
     */
    'city'?: string | null;
    /**
     * 
     * @type {RegisterVesselEntityType}
     * @memberof RegisterVesselOwner
     */
    'entityType': RegisterVesselEntityType;
    /**
     * 
     * @type {number}
     * @memberof RegisterVesselOwner
     */
    'id'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof RegisterVesselOwner
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof RegisterVesselOwner
     */
    'postalCode': number;
}


/**
 * 
 * @export
 * @interface Species
 */
export interface Species {
    /**
     * 
     * @type {number}
     * @memberof Species
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof Species
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface SpeciesFao
 */
export interface SpeciesFao {
    /**
     * 
     * @type {string}
     * @memberof SpeciesFao
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof SpeciesFao
     */
    'name'?: string | null;
}
/**
 * 
 * @export
 * @interface SpeciesFiskeridir
 */
export interface SpeciesFiskeridir {
    /**
     * 
     * @type {number}
     * @memberof SpeciesFiskeridir
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof SpeciesFiskeridir
     */
    'name'?: string | null;
}
/**
 * 
 * @export
 * @interface SpeciesGroup
 */
export interface SpeciesGroup {
    /**
     * 
     * @type {number}
     * @memberof SpeciesGroup
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof SpeciesGroup
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface SpeciesMainGroup
 */
export interface SpeciesMainGroup {
    /**
     * 
     * @type {number}
     * @memberof SpeciesMainGroup
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof SpeciesMainGroup
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface Trip
 */
export interface Trip {
    /**
     * 
     * @type {Delivery}
     * @memberof Trip
     */
    'delivery': Delivery;
    /**
     * 
     * @type {Array<string>}
     * @memberof Trip
     */
    'deliveryPointIds': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Trip
     */
    'end': string;
    /**
     * 
     * @type {string}
     * @memberof Trip
     */
    'endPortId'?: string | null;
    /**
     * 
     * @type {Array<VesselEvent>}
     * @memberof Trip
     */
    'events': Array<VesselEvent>;
    /**
     * 
     * @type {Array<FishingFacility>}
     * @memberof Trip
     */
    'fishingFacilities': Array<FishingFacility>;
    /**
     * 
     * @type {number}
     * @memberof Trip
     */
    'fiskeridirVesselId': number;
    /**
     * 
     * @type {Array<number>}
     * @memberof Trip
     */
    'gearIds': Array<number>;
    /**
     * 
     * @type {Array<Haul>}
     * @memberof Trip
     */
    'hauls': Array<Haul>;
    /**
     * 
     * @type {string}
     * @memberof Trip
     */
    'mostRecentDeliveryDate'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Trip
     */
    'numDeliveries': number;
    /**
     * 
     * @type {string}
     * @memberof Trip
     */
    'start': string;
    /**
     * 
     * @type {string}
     * @memberof Trip
     */
    'startPortId'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Trip
     */
    'tripId': number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const TripSorting = {
    StartDate: 'startDate',
    StopDate: 'stopDate',
    Weight: 'weight'
} as const;

export type TripSorting = typeof TripSorting[keyof typeof TripSorting];


/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {Array<number>}
     * @memberof User
     */
    'following': Array<number>;
}
/**
 * 
 * @export
 * @interface Vessel
 */
export interface Vessel {
    /**
     * 
     * @type {AisVessel}
     * @memberof Vessel
     */
    'ais'?: AisVessel | null;
    /**
     * 
     * @type {number}
     * @memberof Vessel
     */
    'fishCaughtPerHour'?: number | null;
    /**
     * 
     * @type {FiskeridirVessel}
     * @memberof Vessel
     */
    'fiskeridir': FiskeridirVessel;
    /**
     * 
     * @type {Array<number>}
     * @memberof Vessel
     */
    'gearGroups': Array<number>;
}
/**
 * 
 * @export
 * @interface VesselEvent
 */
export interface VesselEvent {
    /**
     * 
     * @type {number}
     * @memberof VesselEvent
     */
    'eventId': number;
    /**
     * 
     * @type {string}
     * @memberof VesselEvent
     */
    'eventName': string;
    /**
     * 
     * @type {number}
     * @memberof VesselEvent
     */
    'eventType': number;
    /**
     * 
     * @type {string}
     * @memberof VesselEvent
     */
    'occurenceTimestamp'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof VesselEvent
     */
    'reportTimestamp': string;
}
/**
 * 
 * @export
 * @interface VmsPosition
 */
export interface VmsPosition {
    /**
     * 
     * @type {number}
     * @memberof VmsPosition
     */
    'course'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof VmsPosition
     */
    'lat': number;
    /**
     * 
     * @type {number}
     * @memberof VmsPosition
     */
    'lon': number;
    /**
     * 
     * @type {number}
     * @memberof VmsPosition
     */
    'speed'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof VmsPosition
     */
    'timestamp': string;
}
/**
 * 
 * @export
 * @interface WhaleCatch
 */
export interface WhaleCatch {
    /**
     * 
     * @type {number}
     * @memberof WhaleCatch
     */
    'blubberMeasureA'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof WhaleCatch
     */
    'blubberMeasureB'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof WhaleCatch
     */
    'blubberMeasureC'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof WhaleCatch
     */
    'circumference'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof WhaleCatch
     */
    'fetusLength'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof WhaleCatch
     */
    'genderId'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof WhaleCatch
     */
    'grenadeNumber': string;
    /**
     * 
     * @type {number}
     * @memberof WhaleCatch
     */
    'individualNumber'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof WhaleCatch
     */
    'length'?: number | null;
}

/**
 * V1aisApi - axios parameter creator
 * @export
 */
export const V1aisApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} mmsi 
         * @param {string} [start] 
         * @param {string} [end] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aisTrack: async (mmsi: number, start?: string, end?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mmsi' is not null or undefined
            assertParamExists('aisTrack', 'mmsi', mmsi)
            const localVarPath = `/v1.0/ais_track/{mmsi}`
                .replace(`{${"mmsi"}}`, encodeURIComponent(String(mmsi)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (start !== undefined) {
                localVarQueryParameter['start'] = (start as any instanceof Date) ?
                    (start as any).toISOString() :
                    start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = (end as any instanceof Date) ?
                    (end as any).toISOString() :
                    end;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * V1aisApi - functional programming interface
 * @export
 */
export const V1aisApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = V1aisApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} mmsi 
         * @param {string} [start] 
         * @param {string} [end] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async aisTrack(mmsi: number, start?: string, end?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AisPosition>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.aisTrack(mmsi, start, end, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * V1aisApi - factory interface
 * @export
 */
export const V1aisApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = V1aisApiFp(configuration)
    return {
        /**
         * 
         * @param {V1aisApiAisTrackRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aisTrack(requestParameters: V1aisApiAisTrackRequest, options?: AxiosRequestConfig): AxiosPromise<Array<AisPosition>> {
            return localVarFp.aisTrack(requestParameters.mmsi, requestParameters.start, requestParameters.end, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for aisTrack operation in V1aisApi.
 * @export
 * @interface V1aisApiAisTrackRequest
 */
export interface V1aisApiAisTrackRequest {
    /**
     * 
     * @type {number}
     * @memberof V1aisApiAisTrack
     */
    readonly mmsi: number

    /**
     * 
     * @type {string}
     * @memberof V1aisApiAisTrack
     */
    readonly start?: string

    /**
     * 
     * @type {string}
     * @memberof V1aisApiAisTrack
     */
    readonly end?: string
}

/**
 * V1aisApi - object-oriented interface
 * @export
 * @class V1aisApi
 * @extends {BaseAPI}
 */
export class V1aisApi extends BaseAPI {
    /**
     * 
     * @param {V1aisApiAisTrackRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1aisApi
     */
    public aisTrack(requestParameters: V1aisApiAisTrackRequest, options?: AxiosRequestConfig) {
        return V1aisApiFp(this.configuration).aisTrack(requestParameters.mmsi, requestParameters.start, requestParameters.end, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * V1aisVmsApi - axios parameter creator
 * @export
 */
export const V1aisVmsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} [mmsi] 
         * @param {string} [callSign] 
         * @param {string} [start] 
         * @param {string} [end] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aisVmsPositions: async (mmsi?: number, callSign?: string, start?: string, end?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1.0/ais_vms_positions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (mmsi !== undefined) {
                localVarQueryParameter['mmsi'] = mmsi;
            }

            if (callSign !== undefined) {
                localVarQueryParameter['callSign'] = callSign;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = (start as any instanceof Date) ?
                    (start as any).toISOString() :
                    start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = (end as any instanceof Date) ?
                    (end as any).toISOString() :
                    end;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * V1aisVmsApi - functional programming interface
 * @export
 */
export const V1aisVmsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = V1aisVmsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} [mmsi] 
         * @param {string} [callSign] 
         * @param {string} [start] 
         * @param {string} [end] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async aisVmsPositions(mmsi?: number, callSign?: string, start?: string, end?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AisVmsPosition>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.aisVmsPositions(mmsi, callSign, start, end, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * V1aisVmsApi - factory interface
 * @export
 */
export const V1aisVmsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = V1aisVmsApiFp(configuration)
    return {
        /**
         * 
         * @param {V1aisVmsApiAisVmsPositionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aisVmsPositions(requestParameters: V1aisVmsApiAisVmsPositionsRequest = {}, options?: AxiosRequestConfig): AxiosPromise<Array<AisVmsPosition>> {
            return localVarFp.aisVmsPositions(requestParameters.mmsi, requestParameters.callSign, requestParameters.start, requestParameters.end, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for aisVmsPositions operation in V1aisVmsApi.
 * @export
 * @interface V1aisVmsApiAisVmsPositionsRequest
 */
export interface V1aisVmsApiAisVmsPositionsRequest {
    /**
     * 
     * @type {number}
     * @memberof V1aisVmsApiAisVmsPositions
     */
    readonly mmsi?: number

    /**
     * 
     * @type {string}
     * @memberof V1aisVmsApiAisVmsPositions
     */
    readonly callSign?: string

    /**
     * 
     * @type {string}
     * @memberof V1aisVmsApiAisVmsPositions
     */
    readonly start?: string

    /**
     * 
     * @type {string}
     * @memberof V1aisVmsApiAisVmsPositions
     */
    readonly end?: string
}

/**
 * V1aisVmsApi - object-oriented interface
 * @export
 * @class V1aisVmsApi
 * @extends {BaseAPI}
 */
export class V1aisVmsApi extends BaseAPI {
    /**
     * 
     * @param {V1aisVmsApiAisVmsPositionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1aisVmsApi
     */
    public aisVmsPositions(requestParameters: V1aisVmsApiAisVmsPositionsRequest = {}, options?: AxiosRequestConfig) {
        return V1aisVmsApiFp(this.configuration).aisVmsPositions(requestParameters.mmsi, requestParameters.callSign, requestParameters.start, requestParameters.end, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * V1deliveryPointApi - axios parameter creator
 * @export
 */
export const V1deliveryPointApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deliveryPoints: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1.0/delivery_points`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * V1deliveryPointApi - functional programming interface
 * @export
 */
export const V1deliveryPointApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = V1deliveryPointApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deliveryPoints(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DeliveryPoint>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deliveryPoints(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * V1deliveryPointApi - factory interface
 * @export
 */
export const V1deliveryPointApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = V1deliveryPointApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deliveryPoints(options?: AxiosRequestConfig): AxiosPromise<Array<DeliveryPoint>> {
            return localVarFp.deliveryPoints(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * V1deliveryPointApi - object-oriented interface
 * @export
 * @class V1deliveryPointApi
 * @extends {BaseAPI}
 */
export class V1deliveryPointApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1deliveryPointApi
     */
    public deliveryPoints(options?: AxiosRequestConfig) {
        return V1deliveryPointApiFp(this.configuration).deliveryPoints(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * V1fishingFacilityApi - axios parameter creator
 * @export
 */
export const V1fishingFacilityApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [mmsis] 
         * @param {string} [fiskeridirVesselIds] 
         * @param {string} [toolTypes] 
         * @param {boolean} [active] 
         * @param {string} [setupRanges] 
         * @param {string} [removedRanges] 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {Ordering} [ordering] 
         * @param {FishingFacilitiesSorting} [sorting] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fishingFacilities: async (mmsis?: string, fiskeridirVesselIds?: string, toolTypes?: string, active?: boolean, setupRanges?: string, removedRanges?: string, limit?: number, offset?: number, ordering?: Ordering, sorting?: FishingFacilitiesSorting, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1.0/fishing_facilities`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (mmsis !== undefined) {
                localVarQueryParameter['mmsis'] = mmsis;
            }

            if (fiskeridirVesselIds !== undefined) {
                localVarQueryParameter['fiskeridirVesselIds'] = fiskeridirVesselIds;
            }

            if (toolTypes !== undefined) {
                localVarQueryParameter['toolTypes'] = toolTypes;
            }

            if (active !== undefined) {
                localVarQueryParameter['active'] = active;
            }

            if (setupRanges !== undefined) {
                localVarQueryParameter['setupRanges'] = setupRanges;
            }

            if (removedRanges !== undefined) {
                localVarQueryParameter['removedRanges'] = removedRanges;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * V1fishingFacilityApi - functional programming interface
 * @export
 */
export const V1fishingFacilityApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = V1fishingFacilityApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} [mmsis] 
         * @param {string} [fiskeridirVesselIds] 
         * @param {string} [toolTypes] 
         * @param {boolean} [active] 
         * @param {string} [setupRanges] 
         * @param {string} [removedRanges] 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {Ordering} [ordering] 
         * @param {FishingFacilitiesSorting} [sorting] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fishingFacilities(mmsis?: string, fiskeridirVesselIds?: string, toolTypes?: string, active?: boolean, setupRanges?: string, removedRanges?: string, limit?: number, offset?: number, ordering?: Ordering, sorting?: FishingFacilitiesSorting, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FishingFacility>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fishingFacilities(mmsis, fiskeridirVesselIds, toolTypes, active, setupRanges, removedRanges, limit, offset, ordering, sorting, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * V1fishingFacilityApi - factory interface
 * @export
 */
export const V1fishingFacilityApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = V1fishingFacilityApiFp(configuration)
    return {
        /**
         * 
         * @param {V1fishingFacilityApiFishingFacilitiesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fishingFacilities(requestParameters: V1fishingFacilityApiFishingFacilitiesRequest = {}, options?: AxiosRequestConfig): AxiosPromise<Array<FishingFacility>> {
            return localVarFp.fishingFacilities(requestParameters.mmsis, requestParameters.fiskeridirVesselIds, requestParameters.toolTypes, requestParameters.active, requestParameters.setupRanges, requestParameters.removedRanges, requestParameters.limit, requestParameters.offset, requestParameters.ordering, requestParameters.sorting, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for fishingFacilities operation in V1fishingFacilityApi.
 * @export
 * @interface V1fishingFacilityApiFishingFacilitiesRequest
 */
export interface V1fishingFacilityApiFishingFacilitiesRequest {
    /**
     * 
     * @type {string}
     * @memberof V1fishingFacilityApiFishingFacilities
     */
    readonly mmsis?: string

    /**
     * 
     * @type {string}
     * @memberof V1fishingFacilityApiFishingFacilities
     */
    readonly fiskeridirVesselIds?: string

    /**
     * 
     * @type {string}
     * @memberof V1fishingFacilityApiFishingFacilities
     */
    readonly toolTypes?: string

    /**
     * 
     * @type {boolean}
     * @memberof V1fishingFacilityApiFishingFacilities
     */
    readonly active?: boolean

    /**
     * 
     * @type {string}
     * @memberof V1fishingFacilityApiFishingFacilities
     */
    readonly setupRanges?: string

    /**
     * 
     * @type {string}
     * @memberof V1fishingFacilityApiFishingFacilities
     */
    readonly removedRanges?: string

    /**
     * 
     * @type {number}
     * @memberof V1fishingFacilityApiFishingFacilities
     */
    readonly limit?: number

    /**
     * 
     * @type {number}
     * @memberof V1fishingFacilityApiFishingFacilities
     */
    readonly offset?: number

    /**
     * 
     * @type {Ordering}
     * @memberof V1fishingFacilityApiFishingFacilities
     */
    readonly ordering?: Ordering

    /**
     * 
     * @type {FishingFacilitiesSorting}
     * @memberof V1fishingFacilityApiFishingFacilities
     */
    readonly sorting?: FishingFacilitiesSorting
}

/**
 * V1fishingFacilityApi - object-oriented interface
 * @export
 * @class V1fishingFacilityApi
 * @extends {BaseAPI}
 */
export class V1fishingFacilityApi extends BaseAPI {
    /**
     * 
     * @param {V1fishingFacilityApiFishingFacilitiesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1fishingFacilityApi
     */
    public fishingFacilities(requestParameters: V1fishingFacilityApiFishingFacilitiesRequest = {}, options?: AxiosRequestConfig) {
        return V1fishingFacilityApiFp(this.configuration).fishingFacilities(requestParameters.mmsis, requestParameters.fiskeridirVesselIds, requestParameters.toolTypes, requestParameters.active, requestParameters.setupRanges, requestParameters.removedRanges, requestParameters.limit, requestParameters.offset, requestParameters.ordering, requestParameters.sorting, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * V1gearApi - axios parameter creator
 * @export
 */
export const V1gearApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gear: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1.0/gear`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gearGroups: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1.0/gear_groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gearMainGroups: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1.0/gear_main_groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * V1gearApi - functional programming interface
 * @export
 */
export const V1gearApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = V1gearApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gear(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Gear>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gear(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gearGroups(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GearGroup>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gearGroups(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gearMainGroups(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GearMainGroup>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gearMainGroups(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * V1gearApi - factory interface
 * @export
 */
export const V1gearApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = V1gearApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gear(options?: AxiosRequestConfig): AxiosPromise<Array<Gear>> {
            return localVarFp.gear(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gearGroups(options?: AxiosRequestConfig): AxiosPromise<Array<GearGroup>> {
            return localVarFp.gearGroups(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gearMainGroups(options?: AxiosRequestConfig): AxiosPromise<Array<GearMainGroup>> {
            return localVarFp.gearMainGroups(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * V1gearApi - object-oriented interface
 * @export
 * @class V1gearApi
 * @extends {BaseAPI}
 */
export class V1gearApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1gearApi
     */
    public gear(options?: AxiosRequestConfig) {
        return V1gearApiFp(this.configuration).gear(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1gearApi
     */
    public gearGroups(options?: AxiosRequestConfig) {
        return V1gearApiFp(this.configuration).gearGroups(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1gearApi
     */
    public gearMainGroups(options?: AxiosRequestConfig) {
        return V1gearApiFp(this.configuration).gearMainGroups(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * V1haulApi - axios parameter creator
 * @export
 */
export const V1haulApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [months] 
         * @param {string} [catchLocations] 
         * @param {string} [gearGroupIds] 
         * @param {string} [speciesGroupIds] 
         * @param {string} [vesselLengthRanges] 
         * @param {string} [fiskeridirVesselIds] 
         * @param {HaulsSorting} [sorting] 
         * @param {Ordering} [ordering] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hauls: async (months?: string, catchLocations?: string, gearGroupIds?: string, speciesGroupIds?: string, vesselLengthRanges?: string, fiskeridirVesselIds?: string, sorting?: HaulsSorting, ordering?: Ordering, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1.0/hauls`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (months !== undefined) {
                localVarQueryParameter['months'] = months;
            }

            if (catchLocations !== undefined) {
                localVarQueryParameter['catchLocations'] = catchLocations;
            }

            if (gearGroupIds !== undefined) {
                localVarQueryParameter['gearGroupIds'] = gearGroupIds;
            }

            if (speciesGroupIds !== undefined) {
                localVarQueryParameter['speciesGroupIds'] = speciesGroupIds;
            }

            if (vesselLengthRanges !== undefined) {
                localVarQueryParameter['vesselLengthRanges'] = vesselLengthRanges;
            }

            if (fiskeridirVesselIds !== undefined) {
                localVarQueryParameter['fiskeridirVesselIds'] = fiskeridirVesselIds;
            }

            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ActiveHaulsFilter} activeFilter What feature to group by on the y-axis of the output matrices
         * @param {string} [months] 
         * @param {string} [catchLocations] 
         * @param {string} [gearGroupIds] 
         * @param {string} [speciesGroupIds] 
         * @param {string} [vesselLengthGroups] 
         * @param {string} [fiskeridirVesselIds] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        haulsMatrix: async (activeFilter: ActiveHaulsFilter, months?: string, catchLocations?: string, gearGroupIds?: string, speciesGroupIds?: string, vesselLengthGroups?: string, fiskeridirVesselIds?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'activeFilter' is not null or undefined
            assertParamExists('haulsMatrix', 'activeFilter', activeFilter)
            const localVarPath = `/v1.0/hauls_matrix/{active_filter}`
                .replace(`{${"active_filter"}}`, encodeURIComponent(String(activeFilter)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (months !== undefined) {
                localVarQueryParameter['months'] = months;
            }

            if (catchLocations !== undefined) {
                localVarQueryParameter['catchLocations'] = catchLocations;
            }

            if (gearGroupIds !== undefined) {
                localVarQueryParameter['gearGroupIds'] = gearGroupIds;
            }

            if (speciesGroupIds !== undefined) {
                localVarQueryParameter['speciesGroupIds'] = speciesGroupIds;
            }

            if (vesselLengthGroups !== undefined) {
                localVarQueryParameter['vesselLengthGroups'] = vesselLengthGroups;
            }

            if (fiskeridirVesselIds !== undefined) {
                localVarQueryParameter['fiskeridirVesselIds'] = fiskeridirVesselIds;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * V1haulApi - functional programming interface
 * @export
 */
export const V1haulApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = V1haulApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} [months] 
         * @param {string} [catchLocations] 
         * @param {string} [gearGroupIds] 
         * @param {string} [speciesGroupIds] 
         * @param {string} [vesselLengthRanges] 
         * @param {string} [fiskeridirVesselIds] 
         * @param {HaulsSorting} [sorting] 
         * @param {Ordering} [ordering] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async hauls(months?: string, catchLocations?: string, gearGroupIds?: string, speciesGroupIds?: string, vesselLengthRanges?: string, fiskeridirVesselIds?: string, sorting?: HaulsSorting, ordering?: Ordering, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Haul>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.hauls(months, catchLocations, gearGroupIds, speciesGroupIds, vesselLengthRanges, fiskeridirVesselIds, sorting, ordering, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {ActiveHaulsFilter} activeFilter What feature to group by on the y-axis of the output matrices
         * @param {string} [months] 
         * @param {string} [catchLocations] 
         * @param {string} [gearGroupIds] 
         * @param {string} [speciesGroupIds] 
         * @param {string} [vesselLengthGroups] 
         * @param {string} [fiskeridirVesselIds] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async haulsMatrix(activeFilter: ActiveHaulsFilter, months?: string, catchLocations?: string, gearGroupIds?: string, speciesGroupIds?: string, vesselLengthGroups?: string, fiskeridirVesselIds?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HaulsMatrix>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.haulsMatrix(activeFilter, months, catchLocations, gearGroupIds, speciesGroupIds, vesselLengthGroups, fiskeridirVesselIds, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * V1haulApi - factory interface
 * @export
 */
export const V1haulApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = V1haulApiFp(configuration)
    return {
        /**
         * 
         * @param {V1haulApiHaulsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hauls(requestParameters: V1haulApiHaulsRequest = {}, options?: AxiosRequestConfig): AxiosPromise<Array<Haul>> {
            return localVarFp.hauls(requestParameters.months, requestParameters.catchLocations, requestParameters.gearGroupIds, requestParameters.speciesGroupIds, requestParameters.vesselLengthRanges, requestParameters.fiskeridirVesselIds, requestParameters.sorting, requestParameters.ordering, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {V1haulApiHaulsMatrixRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        haulsMatrix(requestParameters: V1haulApiHaulsMatrixRequest, options?: AxiosRequestConfig): AxiosPromise<HaulsMatrix> {
            return localVarFp.haulsMatrix(requestParameters.activeFilter, requestParameters.months, requestParameters.catchLocations, requestParameters.gearGroupIds, requestParameters.speciesGroupIds, requestParameters.vesselLengthGroups, requestParameters.fiskeridirVesselIds, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for hauls operation in V1haulApi.
 * @export
 * @interface V1haulApiHaulsRequest
 */
export interface V1haulApiHaulsRequest {
    /**
     * 
     * @type {string}
     * @memberof V1haulApiHauls
     */
    readonly months?: string

    /**
     * 
     * @type {string}
     * @memberof V1haulApiHauls
     */
    readonly catchLocations?: string

    /**
     * 
     * @type {string}
     * @memberof V1haulApiHauls
     */
    readonly gearGroupIds?: string

    /**
     * 
     * @type {string}
     * @memberof V1haulApiHauls
     */
    readonly speciesGroupIds?: string

    /**
     * 
     * @type {string}
     * @memberof V1haulApiHauls
     */
    readonly vesselLengthRanges?: string

    /**
     * 
     * @type {string}
     * @memberof V1haulApiHauls
     */
    readonly fiskeridirVesselIds?: string

    /**
     * 
     * @type {HaulsSorting}
     * @memberof V1haulApiHauls
     */
    readonly sorting?: HaulsSorting

    /**
     * 
     * @type {Ordering}
     * @memberof V1haulApiHauls
     */
    readonly ordering?: Ordering
}

/**
 * Request parameters for haulsMatrix operation in V1haulApi.
 * @export
 * @interface V1haulApiHaulsMatrixRequest
 */
export interface V1haulApiHaulsMatrixRequest {
    /**
     * What feature to group by on the y-axis of the output matrices
     * @type {ActiveHaulsFilter}
     * @memberof V1haulApiHaulsMatrix
     */
    readonly activeFilter: ActiveHaulsFilter

    /**
     * 
     * @type {string}
     * @memberof V1haulApiHaulsMatrix
     */
    readonly months?: string

    /**
     * 
     * @type {string}
     * @memberof V1haulApiHaulsMatrix
     */
    readonly catchLocations?: string

    /**
     * 
     * @type {string}
     * @memberof V1haulApiHaulsMatrix
     */
    readonly gearGroupIds?: string

    /**
     * 
     * @type {string}
     * @memberof V1haulApiHaulsMatrix
     */
    readonly speciesGroupIds?: string

    /**
     * 
     * @type {string}
     * @memberof V1haulApiHaulsMatrix
     */
    readonly vesselLengthGroups?: string

    /**
     * 
     * @type {string}
     * @memberof V1haulApiHaulsMatrix
     */
    readonly fiskeridirVesselIds?: string
}

/**
 * V1haulApi - object-oriented interface
 * @export
 * @class V1haulApi
 * @extends {BaseAPI}
 */
export class V1haulApi extends BaseAPI {
    /**
     * 
     * @param {V1haulApiHaulsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1haulApi
     */
    public hauls(requestParameters: V1haulApiHaulsRequest = {}, options?: AxiosRequestConfig) {
        return V1haulApiFp(this.configuration).hauls(requestParameters.months, requestParameters.catchLocations, requestParameters.gearGroupIds, requestParameters.speciesGroupIds, requestParameters.vesselLengthRanges, requestParameters.fiskeridirVesselIds, requestParameters.sorting, requestParameters.ordering, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {V1haulApiHaulsMatrixRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1haulApi
     */
    public haulsMatrix(requestParameters: V1haulApiHaulsMatrixRequest, options?: AxiosRequestConfig) {
        return V1haulApiFp(this.configuration).haulsMatrix(requestParameters.activeFilter, requestParameters.months, requestParameters.catchLocations, requestParameters.gearGroupIds, requestParameters.speciesGroupIds, requestParameters.vesselLengthGroups, requestParameters.fiskeridirVesselIds, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * V1landingApi - axios parameter creator
 * @export
 */
export const V1landingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ActiveLandingFilter} activeFilter What feature to group by on the y-axis of the output matrices
         * @param {string} [months] 
         * @param {string} [catchLocations] 
         * @param {string} [gearGroupIds] 
         * @param {string} [speciesGroupIds] 
         * @param {string} [vesselLengthGroups] 
         * @param {string} [fiskeridirVesselIds] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        landingMatrix: async (activeFilter: ActiveLandingFilter, months?: string, catchLocations?: string, gearGroupIds?: string, speciesGroupIds?: string, vesselLengthGroups?: string, fiskeridirVesselIds?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'activeFilter' is not null or undefined
            assertParamExists('landingMatrix', 'activeFilter', activeFilter)
            const localVarPath = `/v1.0/landing_matrix/{active_filter}`
                .replace(`{${"active_filter"}}`, encodeURIComponent(String(activeFilter)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (months !== undefined) {
                localVarQueryParameter['months'] = months;
            }

            if (catchLocations !== undefined) {
                localVarQueryParameter['catchLocations'] = catchLocations;
            }

            if (gearGroupIds !== undefined) {
                localVarQueryParameter['gearGroupIds'] = gearGroupIds;
            }

            if (speciesGroupIds !== undefined) {
                localVarQueryParameter['speciesGroupIds'] = speciesGroupIds;
            }

            if (vesselLengthGroups !== undefined) {
                localVarQueryParameter['vesselLengthGroups'] = vesselLengthGroups;
            }

            if (fiskeridirVesselIds !== undefined) {
                localVarQueryParameter['fiskeridirVesselIds'] = fiskeridirVesselIds;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [months] 
         * @param {string} [catchLocations] 
         * @param {string} [gearGroupIds] 
         * @param {string} [speciesGroupIds] 
         * @param {string} [vesselLengthRanges] 
         * @param {string} [fiskeridirVesselIds] 
         * @param {LandingsSorting} [sorting] 
         * @param {Ordering} [ordering] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        landings: async (months?: string, catchLocations?: string, gearGroupIds?: string, speciesGroupIds?: string, vesselLengthRanges?: string, fiskeridirVesselIds?: string, sorting?: LandingsSorting, ordering?: Ordering, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1.0/landings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (months !== undefined) {
                localVarQueryParameter['months'] = months;
            }

            if (catchLocations !== undefined) {
                localVarQueryParameter['catchLocations'] = catchLocations;
            }

            if (gearGroupIds !== undefined) {
                localVarQueryParameter['gearGroupIds'] = gearGroupIds;
            }

            if (speciesGroupIds !== undefined) {
                localVarQueryParameter['speciesGroupIds'] = speciesGroupIds;
            }

            if (vesselLengthRanges !== undefined) {
                localVarQueryParameter['vesselLengthRanges'] = vesselLengthRanges;
            }

            if (fiskeridirVesselIds !== undefined) {
                localVarQueryParameter['fiskeridirVesselIds'] = fiskeridirVesselIds;
            }

            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * V1landingApi - functional programming interface
 * @export
 */
export const V1landingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = V1landingApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {ActiveLandingFilter} activeFilter What feature to group by on the y-axis of the output matrices
         * @param {string} [months] 
         * @param {string} [catchLocations] 
         * @param {string} [gearGroupIds] 
         * @param {string} [speciesGroupIds] 
         * @param {string} [vesselLengthGroups] 
         * @param {string} [fiskeridirVesselIds] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async landingMatrix(activeFilter: ActiveLandingFilter, months?: string, catchLocations?: string, gearGroupIds?: string, speciesGroupIds?: string, vesselLengthGroups?: string, fiskeridirVesselIds?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LandingMatrix>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.landingMatrix(activeFilter, months, catchLocations, gearGroupIds, speciesGroupIds, vesselLengthGroups, fiskeridirVesselIds, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [months] 
         * @param {string} [catchLocations] 
         * @param {string} [gearGroupIds] 
         * @param {string} [speciesGroupIds] 
         * @param {string} [vesselLengthRanges] 
         * @param {string} [fiskeridirVesselIds] 
         * @param {LandingsSorting} [sorting] 
         * @param {Ordering} [ordering] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async landings(months?: string, catchLocations?: string, gearGroupIds?: string, speciesGroupIds?: string, vesselLengthRanges?: string, fiskeridirVesselIds?: string, sorting?: LandingsSorting, ordering?: Ordering, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Landing>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.landings(months, catchLocations, gearGroupIds, speciesGroupIds, vesselLengthRanges, fiskeridirVesselIds, sorting, ordering, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * V1landingApi - factory interface
 * @export
 */
export const V1landingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = V1landingApiFp(configuration)
    return {
        /**
         * 
         * @param {V1landingApiLandingMatrixRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        landingMatrix(requestParameters: V1landingApiLandingMatrixRequest, options?: AxiosRequestConfig): AxiosPromise<LandingMatrix> {
            return localVarFp.landingMatrix(requestParameters.activeFilter, requestParameters.months, requestParameters.catchLocations, requestParameters.gearGroupIds, requestParameters.speciesGroupIds, requestParameters.vesselLengthGroups, requestParameters.fiskeridirVesselIds, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {V1landingApiLandingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        landings(requestParameters: V1landingApiLandingsRequest = {}, options?: AxiosRequestConfig): AxiosPromise<Array<Landing>> {
            return localVarFp.landings(requestParameters.months, requestParameters.catchLocations, requestParameters.gearGroupIds, requestParameters.speciesGroupIds, requestParameters.vesselLengthRanges, requestParameters.fiskeridirVesselIds, requestParameters.sorting, requestParameters.ordering, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for landingMatrix operation in V1landingApi.
 * @export
 * @interface V1landingApiLandingMatrixRequest
 */
export interface V1landingApiLandingMatrixRequest {
    /**
     * What feature to group by on the y-axis of the output matrices
     * @type {ActiveLandingFilter}
     * @memberof V1landingApiLandingMatrix
     */
    readonly activeFilter: ActiveLandingFilter

    /**
     * 
     * @type {string}
     * @memberof V1landingApiLandingMatrix
     */
    readonly months?: string

    /**
     * 
     * @type {string}
     * @memberof V1landingApiLandingMatrix
     */
    readonly catchLocations?: string

    /**
     * 
     * @type {string}
     * @memberof V1landingApiLandingMatrix
     */
    readonly gearGroupIds?: string

    /**
     * 
     * @type {string}
     * @memberof V1landingApiLandingMatrix
     */
    readonly speciesGroupIds?: string

    /**
     * 
     * @type {string}
     * @memberof V1landingApiLandingMatrix
     */
    readonly vesselLengthGroups?: string

    /**
     * 
     * @type {string}
     * @memberof V1landingApiLandingMatrix
     */
    readonly fiskeridirVesselIds?: string
}

/**
 * Request parameters for landings operation in V1landingApi.
 * @export
 * @interface V1landingApiLandingsRequest
 */
export interface V1landingApiLandingsRequest {
    /**
     * 
     * @type {string}
     * @memberof V1landingApiLandings
     */
    readonly months?: string

    /**
     * 
     * @type {string}
     * @memberof V1landingApiLandings
     */
    readonly catchLocations?: string

    /**
     * 
     * @type {string}
     * @memberof V1landingApiLandings
     */
    readonly gearGroupIds?: string

    /**
     * 
     * @type {string}
     * @memberof V1landingApiLandings
     */
    readonly speciesGroupIds?: string

    /**
     * 
     * @type {string}
     * @memberof V1landingApiLandings
     */
    readonly vesselLengthRanges?: string

    /**
     * 
     * @type {string}
     * @memberof V1landingApiLandings
     */
    readonly fiskeridirVesselIds?: string

    /**
     * 
     * @type {LandingsSorting}
     * @memberof V1landingApiLandings
     */
    readonly sorting?: LandingsSorting

    /**
     * 
     * @type {Ordering}
     * @memberof V1landingApiLandings
     */
    readonly ordering?: Ordering
}

/**
 * V1landingApi - object-oriented interface
 * @export
 * @class V1landingApi
 * @extends {BaseAPI}
 */
export class V1landingApi extends BaseAPI {
    /**
     * 
     * @param {V1landingApiLandingMatrixRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1landingApi
     */
    public landingMatrix(requestParameters: V1landingApiLandingMatrixRequest, options?: AxiosRequestConfig) {
        return V1landingApiFp(this.configuration).landingMatrix(requestParameters.activeFilter, requestParameters.months, requestParameters.catchLocations, requestParameters.gearGroupIds, requestParameters.speciesGroupIds, requestParameters.vesselLengthGroups, requestParameters.fiskeridirVesselIds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {V1landingApiLandingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1landingApi
     */
    public landings(requestParameters: V1landingApiLandingsRequest = {}, options?: AxiosRequestConfig) {
        return V1landingApiFp(this.configuration).landings(requestParameters.months, requestParameters.catchLocations, requestParameters.gearGroupIds, requestParameters.speciesGroupIds, requestParameters.vesselLengthRanges, requestParameters.fiskeridirVesselIds, requestParameters.sorting, requestParameters.ordering, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * V1speciesApi - axios parameter creator
 * @export
 */
export const V1speciesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        species: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1.0/species`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        speciesFao: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1.0/species_fao`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        speciesFiskeridir: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1.0/species_fiskeridir`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        speciesGroups: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1.0/species_groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        speciesMainGroups: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1.0/species_main_groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * V1speciesApi - functional programming interface
 * @export
 */
export const V1speciesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = V1speciesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async species(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Species>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.species(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async speciesFao(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SpeciesFao>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.speciesFao(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async speciesFiskeridir(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SpeciesFiskeridir>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.speciesFiskeridir(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async speciesGroups(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SpeciesGroup>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.speciesGroups(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async speciesMainGroups(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SpeciesMainGroup>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.speciesMainGroups(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * V1speciesApi - factory interface
 * @export
 */
export const V1speciesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = V1speciesApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        species(options?: AxiosRequestConfig): AxiosPromise<Array<Species>> {
            return localVarFp.species(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        speciesFao(options?: AxiosRequestConfig): AxiosPromise<Array<SpeciesFao>> {
            return localVarFp.speciesFao(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        speciesFiskeridir(options?: AxiosRequestConfig): AxiosPromise<Array<SpeciesFiskeridir>> {
            return localVarFp.speciesFiskeridir(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        speciesGroups(options?: AxiosRequestConfig): AxiosPromise<Array<SpeciesGroup>> {
            return localVarFp.speciesGroups(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        speciesMainGroups(options?: AxiosRequestConfig): AxiosPromise<Array<SpeciesMainGroup>> {
            return localVarFp.speciesMainGroups(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * V1speciesApi - object-oriented interface
 * @export
 * @class V1speciesApi
 * @extends {BaseAPI}
 */
export class V1speciesApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1speciesApi
     */
    public species(options?: AxiosRequestConfig) {
        return V1speciesApiFp(this.configuration).species(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1speciesApi
     */
    public speciesFao(options?: AxiosRequestConfig) {
        return V1speciesApiFp(this.configuration).speciesFao(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1speciesApi
     */
    public speciesFiskeridir(options?: AxiosRequestConfig) {
        return V1speciesApiFp(this.configuration).speciesFiskeridir(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1speciesApi
     */
    public speciesGroups(options?: AxiosRequestConfig) {
        return V1speciesApiFp(this.configuration).speciesGroups(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1speciesApi
     */
    public speciesMainGroups(options?: AxiosRequestConfig) {
        return V1speciesApiFp(this.configuration).speciesMainGroups(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * V1tripApi - axios parameter creator
 * @export
 */
export const V1tripApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} fiskeridirVesselId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currentTrip: async (fiskeridirVesselId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fiskeridirVesselId' is not null or undefined
            assertParamExists('currentTrip', 'fiskeridirVesselId', fiskeridirVesselId)
            const localVarPath = `/v1.0/trips/current/{fiskeridir_vessel_id}`
                .replace(`{${"fiskeridir_vessel_id"}}`, encodeURIComponent(String(fiskeridirVesselId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} haulId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tripOfHaul: async (haulId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'haulId' is not null or undefined
            assertParamExists('tripOfHaul', 'haulId', haulId)
            const localVarPath = `/v1.0/trip_of_haul/{haul_id}`
                .replace(`{${"haul_id"}}`, encodeURIComponent(String(haulId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} landingId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tripOfLanding: async (landingId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'landingId' is not null or undefined
            assertParamExists('tripOfLanding', 'landingId', landingId)
            const localVarPath = `/v1.0/trip_of_landing/{landing_id}`
                .replace(`{${"landing_id"}}`, encodeURIComponent(String(landingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {Ordering} [ordering] 
         * @param {string} [deliveryPoints] 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {number} [minWeight] 
         * @param {number} [maxWeight] 
         * @param {TripSorting} [sorting] 
         * @param {string} [gearGroupIds] 
         * @param {string} [speciesGroupIds] 
         * @param {string} [vesselLengthGroups] 
         * @param {string} [fiskeridirVesselIds] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trips: async (limit?: number, offset?: number, ordering?: Ordering, deliveryPoints?: string, startDate?: string, endDate?: string, minWeight?: number, maxWeight?: number, sorting?: TripSorting, gearGroupIds?: string, speciesGroupIds?: string, vesselLengthGroups?: string, fiskeridirVesselIds?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1.0/trips`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (deliveryPoints !== undefined) {
                localVarQueryParameter['deliveryPoints'] = deliveryPoints;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any instanceof Date) ?
                    (startDate as any).toISOString() :
                    startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any instanceof Date) ?
                    (endDate as any).toISOString() :
                    endDate;
            }

            if (minWeight !== undefined) {
                localVarQueryParameter['minWeight'] = minWeight;
            }

            if (maxWeight !== undefined) {
                localVarQueryParameter['maxWeight'] = maxWeight;
            }

            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }

            if (gearGroupIds !== undefined) {
                localVarQueryParameter['gearGroupIds'] = gearGroupIds;
            }

            if (speciesGroupIds !== undefined) {
                localVarQueryParameter['speciesGroupIds'] = speciesGroupIds;
            }

            if (vesselLengthGroups !== undefined) {
                localVarQueryParameter['vesselLengthGroups'] = vesselLengthGroups;
            }

            if (fiskeridirVesselIds !== undefined) {
                localVarQueryParameter['fiskeridirVesselIds'] = fiskeridirVesselIds;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} fiskeridirVesselId 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {Ordering} [ordering] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tripsOfVessel: async (fiskeridirVesselId: number, limit?: number, offset?: number, ordering?: Ordering, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fiskeridirVesselId' is not null or undefined
            assertParamExists('tripsOfVessel', 'fiskeridirVesselId', fiskeridirVesselId)
            const localVarPath = `/v1.0/trips/{fiskeridir_vessel_id}`
                .replace(`{${"fiskeridir_vessel_id"}}`, encodeURIComponent(String(fiskeridirVesselId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * V1tripApi - functional programming interface
 * @export
 */
export const V1tripApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = V1tripApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} fiskeridirVesselId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async currentTrip(fiskeridirVesselId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CurrentTrip>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.currentTrip(fiskeridirVesselId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} haulId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tripOfHaul(haulId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Trip>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tripOfHaul(haulId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} landingId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tripOfLanding(landingId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Trip>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tripOfLanding(landingId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {Ordering} [ordering] 
         * @param {string} [deliveryPoints] 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {number} [minWeight] 
         * @param {number} [maxWeight] 
         * @param {TripSorting} [sorting] 
         * @param {string} [gearGroupIds] 
         * @param {string} [speciesGroupIds] 
         * @param {string} [vesselLengthGroups] 
         * @param {string} [fiskeridirVesselIds] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trips(limit?: number, offset?: number, ordering?: Ordering, deliveryPoints?: string, startDate?: string, endDate?: string, minWeight?: number, maxWeight?: number, sorting?: TripSorting, gearGroupIds?: string, speciesGroupIds?: string, vesselLengthGroups?: string, fiskeridirVesselIds?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Trip>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trips(limit, offset, ordering, deliveryPoints, startDate, endDate, minWeight, maxWeight, sorting, gearGroupIds, speciesGroupIds, vesselLengthGroups, fiskeridirVesselIds, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} fiskeridirVesselId 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {Ordering} [ordering] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tripsOfVessel(fiskeridirVesselId: number, limit?: number, offset?: number, ordering?: Ordering, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Trip>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tripsOfVessel(fiskeridirVesselId, limit, offset, ordering, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * V1tripApi - factory interface
 * @export
 */
export const V1tripApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = V1tripApiFp(configuration)
    return {
        /**
         * 
         * @param {V1tripApiCurrentTripRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currentTrip(requestParameters: V1tripApiCurrentTripRequest, options?: AxiosRequestConfig): AxiosPromise<CurrentTrip> {
            return localVarFp.currentTrip(requestParameters.fiskeridirVesselId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {V1tripApiTripOfHaulRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tripOfHaul(requestParameters: V1tripApiTripOfHaulRequest, options?: AxiosRequestConfig): AxiosPromise<Trip> {
            return localVarFp.tripOfHaul(requestParameters.haulId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {V1tripApiTripOfLandingRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tripOfLanding(requestParameters: V1tripApiTripOfLandingRequest, options?: AxiosRequestConfig): AxiosPromise<Trip> {
            return localVarFp.tripOfLanding(requestParameters.landingId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {V1tripApiTripsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trips(requestParameters: V1tripApiTripsRequest = {}, options?: AxiosRequestConfig): AxiosPromise<Array<Trip>> {
            return localVarFp.trips(requestParameters.limit, requestParameters.offset, requestParameters.ordering, requestParameters.deliveryPoints, requestParameters.startDate, requestParameters.endDate, requestParameters.minWeight, requestParameters.maxWeight, requestParameters.sorting, requestParameters.gearGroupIds, requestParameters.speciesGroupIds, requestParameters.vesselLengthGroups, requestParameters.fiskeridirVesselIds, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {V1tripApiTripsOfVesselRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tripsOfVessel(requestParameters: V1tripApiTripsOfVesselRequest, options?: AxiosRequestConfig): AxiosPromise<Array<Trip>> {
            return localVarFp.tripsOfVessel(requestParameters.fiskeridirVesselId, requestParameters.limit, requestParameters.offset, requestParameters.ordering, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for currentTrip operation in V1tripApi.
 * @export
 * @interface V1tripApiCurrentTripRequest
 */
export interface V1tripApiCurrentTripRequest {
    /**
     * 
     * @type {number}
     * @memberof V1tripApiCurrentTrip
     */
    readonly fiskeridirVesselId: number
}

/**
 * Request parameters for tripOfHaul operation in V1tripApi.
 * @export
 * @interface V1tripApiTripOfHaulRequest
 */
export interface V1tripApiTripOfHaulRequest {
    /**
     * 
     * @type {number}
     * @memberof V1tripApiTripOfHaul
     */
    readonly haulId: number
}

/**
 * Request parameters for tripOfLanding operation in V1tripApi.
 * @export
 * @interface V1tripApiTripOfLandingRequest
 */
export interface V1tripApiTripOfLandingRequest {
    /**
     * 
     * @type {string}
     * @memberof V1tripApiTripOfLanding
     */
    readonly landingId: string
}

/**
 * Request parameters for trips operation in V1tripApi.
 * @export
 * @interface V1tripApiTripsRequest
 */
export interface V1tripApiTripsRequest {
    /**
     * 
     * @type {number}
     * @memberof V1tripApiTrips
     */
    readonly limit?: number

    /**
     * 
     * @type {number}
     * @memberof V1tripApiTrips
     */
    readonly offset?: number

    /**
     * 
     * @type {Ordering}
     * @memberof V1tripApiTrips
     */
    readonly ordering?: Ordering

    /**
     * 
     * @type {string}
     * @memberof V1tripApiTrips
     */
    readonly deliveryPoints?: string

    /**
     * 
     * @type {string}
     * @memberof V1tripApiTrips
     */
    readonly startDate?: string

    /**
     * 
     * @type {string}
     * @memberof V1tripApiTrips
     */
    readonly endDate?: string

    /**
     * 
     * @type {number}
     * @memberof V1tripApiTrips
     */
    readonly minWeight?: number

    /**
     * 
     * @type {number}
     * @memberof V1tripApiTrips
     */
    readonly maxWeight?: number

    /**
     * 
     * @type {TripSorting}
     * @memberof V1tripApiTrips
     */
    readonly sorting?: TripSorting

    /**
     * 
     * @type {string}
     * @memberof V1tripApiTrips
     */
    readonly gearGroupIds?: string

    /**
     * 
     * @type {string}
     * @memberof V1tripApiTrips
     */
    readonly speciesGroupIds?: string

    /**
     * 
     * @type {string}
     * @memberof V1tripApiTrips
     */
    readonly vesselLengthGroups?: string

    /**
     * 
     * @type {string}
     * @memberof V1tripApiTrips
     */
    readonly fiskeridirVesselIds?: string
}

/**
 * Request parameters for tripsOfVessel operation in V1tripApi.
 * @export
 * @interface V1tripApiTripsOfVesselRequest
 */
export interface V1tripApiTripsOfVesselRequest {
    /**
     * 
     * @type {number}
     * @memberof V1tripApiTripsOfVessel
     */
    readonly fiskeridirVesselId: number

    /**
     * 
     * @type {number}
     * @memberof V1tripApiTripsOfVessel
     */
    readonly limit?: number

    /**
     * 
     * @type {number}
     * @memberof V1tripApiTripsOfVessel
     */
    readonly offset?: number

    /**
     * 
     * @type {Ordering}
     * @memberof V1tripApiTripsOfVessel
     */
    readonly ordering?: Ordering
}

/**
 * V1tripApi - object-oriented interface
 * @export
 * @class V1tripApi
 * @extends {BaseAPI}
 */
export class V1tripApi extends BaseAPI {
    /**
     * 
     * @param {V1tripApiCurrentTripRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1tripApi
     */
    public currentTrip(requestParameters: V1tripApiCurrentTripRequest, options?: AxiosRequestConfig) {
        return V1tripApiFp(this.configuration).currentTrip(requestParameters.fiskeridirVesselId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {V1tripApiTripOfHaulRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1tripApi
     */
    public tripOfHaul(requestParameters: V1tripApiTripOfHaulRequest, options?: AxiosRequestConfig) {
        return V1tripApiFp(this.configuration).tripOfHaul(requestParameters.haulId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {V1tripApiTripOfLandingRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1tripApi
     */
    public tripOfLanding(requestParameters: V1tripApiTripOfLandingRequest, options?: AxiosRequestConfig) {
        return V1tripApiFp(this.configuration).tripOfLanding(requestParameters.landingId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {V1tripApiTripsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1tripApi
     */
    public trips(requestParameters: V1tripApiTripsRequest = {}, options?: AxiosRequestConfig) {
        return V1tripApiFp(this.configuration).trips(requestParameters.limit, requestParameters.offset, requestParameters.ordering, requestParameters.deliveryPoints, requestParameters.startDate, requestParameters.endDate, requestParameters.minWeight, requestParameters.maxWeight, requestParameters.sorting, requestParameters.gearGroupIds, requestParameters.speciesGroupIds, requestParameters.vesselLengthGroups, requestParameters.fiskeridirVesselIds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {V1tripApiTripsOfVesselRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1tripApi
     */
    public tripsOfVessel(requestParameters: V1tripApiTripsOfVesselRequest, options?: AxiosRequestConfig) {
        return V1tripApiFp(this.configuration).tripsOfVessel(requestParameters.fiskeridirVesselId, requestParameters.limit, requestParameters.offset, requestParameters.ordering, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * V1userApi - axios parameter creator
 * @export
 */
export const V1userApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1.0/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {User} user updated user information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser: async (user: User, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('updateUser', 'user', user)
            const localVarPath = `/v1.0/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(user, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * V1userApi - functional programming interface
 * @export
 */
export const V1userApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = V1userApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUser(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {User} user updated user information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUser(user: User, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser(user, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * V1userApi - factory interface
 * @export
 */
export const V1userApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = V1userApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(options?: AxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.getUser(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {V1userApiUpdateUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(requestParameters: V1userApiUpdateUserRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateUser(requestParameters.user, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for updateUser operation in V1userApi.
 * @export
 * @interface V1userApiUpdateUserRequest
 */
export interface V1userApiUpdateUserRequest {
    /**
     * updated user information
     * @type {User}
     * @memberof V1userApiUpdateUser
     */
    readonly user: User
}

/**
 * V1userApi - object-oriented interface
 * @export
 * @class V1userApi
 * @extends {BaseAPI}
 */
export class V1userApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1userApi
     */
    public getUser(options?: AxiosRequestConfig) {
        return V1userApiFp(this.configuration).getUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {V1userApiUpdateUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1userApi
     */
    public updateUser(requestParameters: V1userApiUpdateUserRequest, options?: AxiosRequestConfig) {
        return V1userApiFp(this.configuration).updateUser(requestParameters.user, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * V1vesselApi - axios parameter creator
 * @export
 */
export const V1vesselApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vessels: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1.0/vessels`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * V1vesselApi - functional programming interface
 * @export
 */
export const V1vesselApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = V1vesselApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async vessels(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Vessel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.vessels(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * V1vesselApi - factory interface
 * @export
 */
export const V1vesselApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = V1vesselApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vessels(options?: AxiosRequestConfig): AxiosPromise<Array<Vessel>> {
            return localVarFp.vessels(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * V1vesselApi - object-oriented interface
 * @export
 * @class V1vesselApi
 * @extends {BaseAPI}
 */
export class V1vesselApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1vesselApi
     */
    public vessels(options?: AxiosRequestConfig) {
        return V1vesselApiFp(this.configuration).vessels(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * V1vmsApi - axios parameter creator
 * @export
 */
export const V1vmsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} callSign 
         * @param {string} [start] 
         * @param {string} [end] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vmsPositions: async (callSign: string, start?: string, end?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'callSign' is not null or undefined
            assertParamExists('vmsPositions', 'callSign', callSign)
            const localVarPath = `/v1.0/vms/{call_sign}`
                .replace(`{${"call_sign"}}`, encodeURIComponent(String(callSign)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (start !== undefined) {
                localVarQueryParameter['start'] = (start as any instanceof Date) ?
                    (start as any).toISOString() :
                    start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = (end as any instanceof Date) ?
                    (end as any).toISOString() :
                    end;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * V1vmsApi - functional programming interface
 * @export
 */
export const V1vmsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = V1vmsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} callSign 
         * @param {string} [start] 
         * @param {string} [end] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async vmsPositions(callSign: string, start?: string, end?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<VmsPosition>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.vmsPositions(callSign, start, end, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * V1vmsApi - factory interface
 * @export
 */
export const V1vmsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = V1vmsApiFp(configuration)
    return {
        /**
         * 
         * @param {V1vmsApiVmsPositionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vmsPositions(requestParameters: V1vmsApiVmsPositionsRequest, options?: AxiosRequestConfig): AxiosPromise<Array<VmsPosition>> {
            return localVarFp.vmsPositions(requestParameters.callSign, requestParameters.start, requestParameters.end, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for vmsPositions operation in V1vmsApi.
 * @export
 * @interface V1vmsApiVmsPositionsRequest
 */
export interface V1vmsApiVmsPositionsRequest {
    /**
     * 
     * @type {string}
     * @memberof V1vmsApiVmsPositions
     */
    readonly callSign: string

    /**
     * 
     * @type {string}
     * @memberof V1vmsApiVmsPositions
     */
    readonly start?: string

    /**
     * 
     * @type {string}
     * @memberof V1vmsApiVmsPositions
     */
    readonly end?: string
}

/**
 * V1vmsApi - object-oriented interface
 * @export
 * @class V1vmsApi
 * @extends {BaseAPI}
 */
export class V1vmsApi extends BaseAPI {
    /**
     * 
     * @param {V1vmsApiVmsPositionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1vmsApi
     */
    public vmsPositions(requestParameters: V1vmsApiVmsPositionsRequest, options?: AxiosRequestConfig) {
        return V1vmsApiFp(this.configuration).vmsPositions(requestParameters.callSign, requestParameters.start, requestParameters.end, options).then((request) => request(this.axios, this.basePath));
    }
}


