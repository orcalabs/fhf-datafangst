/* tslint:disable */
/* eslint-disable */
/**
 * web-api
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1.0
 * Contact: contact@orcalabs.no
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @enum {string}
 */

export const ActiveHaulsFilter = {
    Date: 'Date',
    GearGroup: 'GearGroup',
    SpeciesGroup: 'SpeciesGroup',
    VesselLength: 'VesselLength'
} as const;

export type ActiveHaulsFilter = typeof ActiveHaulsFilter[keyof typeof ActiveHaulsFilter];


/**
 * 
 * @export
 * @enum {string}
 */

export const ActiveLandingFilter = {
    Date: 'Date',
    GearGroup: 'GearGroup',
    SpeciesGroup: 'SpeciesGroup',
    VesselLength: 'VesselLength'
} as const;

export type ActiveLandingFilter = typeof ActiveLandingFilter[keyof typeof ActiveLandingFilter];


/**
 * 
 * @export
 * @interface AisPosition
 */
export interface AisPosition {
    /**
     * 
     * @type {number}
     * @memberof AisPosition
     */
    'cog'?: number | null;
    /**
     * 
     * @type {AisPositionDetails}
     * @memberof AisPosition
     */
    'det'?: AisPositionDetails | null;
    /**
     * 
     * @type {number}
     * @memberof AisPosition
     */
    'lat': number;
    /**
     * 
     * @type {number}
     * @memberof AisPosition
     */
    'lon': number;
    /**
     * 
     * @type {string}
     * @memberof AisPosition
     */
    'timestamp': string;
}
/**
 * 
 * @export
 * @interface AisPositionDetails
 */
export interface AisPositionDetails {
    /**
     * 
     * @type {number}
     * @memberof AisPositionDetails
     */
    'distanceToShore': number;
    /**
     * 
     * @type {boolean}
     * @memberof AisPositionDetails
     */
    'missingData': boolean;
    /**
     * 
     * @type {NavigationStatus}
     * @memberof AisPositionDetails
     */
    'navigationalStatus'?: NavigationStatus | null;
    /**
     * 
     * @type {number}
     * @memberof AisPositionDetails
     */
    'rateOfTurn'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof AisPositionDetails
     */
    'speedOverGround'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof AisPositionDetails
     */
    'trueHeading'?: number | null;
}
/**
 * 
 * @export
 * @interface AisVessel
 */
export interface AisVessel {
    /**
     * 
     * @type {string}
     * @memberof AisVessel
     */
    'callSign'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AisVessel
     */
    'destination'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AisVessel
     */
    'eta'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof AisVessel
     */
    'imoNumber'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof AisVessel
     */
    'mmsi': number;
    /**
     * 
     * @type {string}
     * @memberof AisVessel
     */
    'name'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof AisVessel
     */
    'shipLength'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof AisVessel
     */
    'shipWidth'?: number | null;
}
/**
 * 
 * @export
 * @interface AisVmsPosition
 */
export interface AisVmsPosition {
    /**
     * 
     * @type {number}
     * @memberof AisVmsPosition
     */
    'cog'?: number | null;
    /**
     * 
     * @type {AisVmsPositionDetails}
     * @memberof AisVmsPosition
     */
    'det'?: AisVmsPositionDetails | null;
    /**
     * 
     * @type {number}
     * @memberof AisVmsPosition
     */
    'lat': number;
    /**
     * 
     * @type {number}
     * @memberof AisVmsPosition
     */
    'lon': number;
    /**
     * 
     * @type {TripPositionLayerId}
     * @memberof AisVmsPosition
     */
    'prunedBy'?: TripPositionLayerId | null;
    /**
     * 
     * @type {number}
     * @memberof AisVmsPosition
     */
    'speed'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof AisVmsPosition
     */
    'timestamp': string;
}
/**
 * 
 * @export
 * @interface AisVmsPositionDetails
 */
export interface AisVmsPositionDetails {
    /**
     * 
     * @type {number}
     * @memberof AisVmsPositionDetails
     */
    'distanceToShore': number;
    /**
     * 
     * @type {boolean}
     * @memberof AisVmsPositionDetails
     */
    'missingData': boolean;
    /**
     * 
     * @type {NavigationStatus}
     * @memberof AisVmsPositionDetails
     */
    'navigationalStatus'?: NavigationStatus | null;
    /**
     * 
     * @type {number}
     * @memberof AisVmsPositionDetails
     */
    'rateOfTurn'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof AisVmsPositionDetails
     */
    'trueHeading'?: number | null;
}
/**
 * @type ApiError
 * @export
 */
export type ApiError = ApiErrorOneOf | ApiErrorOneOf1 | ApiErrorOneOf10 | ApiErrorOneOf11 | ApiErrorOneOf2 | ApiErrorOneOf3 | ApiErrorOneOf4 | ApiErrorOneOf5 | ApiErrorOneOf6 | ApiErrorOneOf7 | ApiErrorOneOf8 | ApiErrorOneOf9;

/**
 * 
 * @export
 * @interface ApiErrorOneOf
 */
export interface ApiErrorOneOf {
    /**
     * 
     * @type {ApiErrorOneOfStartAfterEnd}
     * @memberof ApiErrorOneOf
     */
    'StartAfterEnd': ApiErrorOneOfStartAfterEnd;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ApiErrorOneOf1 = {
    InvalidCallSign: 'InvalidCallSign'
} as const;

export type ApiErrorOneOf1 = typeof ApiErrorOneOf1[keyof typeof ApiErrorOneOf1];


/**
 * 
 * @export
 * @enum {string}
 */

export const ApiErrorOneOf10 = {
    InvalidAuthToken: 'InvalidAuthToken'
} as const;

export type ApiErrorOneOf10 = typeof ApiErrorOneOf10[keyof typeof ApiErrorOneOf10];


/**
 * 
 * @export
 * @enum {string}
 */

export const ApiErrorOneOf11 = {
    MissingAuthToken: 'MissingAuthToken'
} as const;

export type ApiErrorOneOf11 = typeof ApiErrorOneOf11[keyof typeof ApiErrorOneOf11];


/**
 * 
 * @export
 * @enum {string}
 */

export const ApiErrorOneOf2 = {
    InvalidDateRange: 'InvalidDateRange'
} as const;

export type ApiErrorOneOf2 = typeof ApiErrorOneOf2[keyof typeof ApiErrorOneOf2];


/**
 * 
 * @export
 * @enum {string}
 */

export const ApiErrorOneOf3 = {
    InternalServerError: 'InternalServerError'
} as const;

export type ApiErrorOneOf3 = typeof ApiErrorOneOf3[keyof typeof ApiErrorOneOf3];


/**
 * 
 * @export
 * @enum {string}
 */

export const ApiErrorOneOf4 = {
    MissingMmsiOrCallSignOrTripId: 'MissingMmsiOrCallSignOrTripId'
} as const;

export type ApiErrorOneOf4 = typeof ApiErrorOneOf4[keyof typeof ApiErrorOneOf4];


/**
 * 
 * @export
 * @enum {string}
 */

export const ApiErrorOneOf5 = {
    Forbidden: 'Forbidden'
} as const;

export type ApiErrorOneOf5 = typeof ApiErrorOneOf5[keyof typeof ApiErrorOneOf5];


/**
 * 
 * @export
 * @enum {string}
 */

export const ApiErrorOneOf6 = {
    MissingBwToken: 'MissingBwToken'
} as const;

export type ApiErrorOneOf6 = typeof ApiErrorOneOf6[keyof typeof ApiErrorOneOf6];


/**
 * 
 * @export
 * @enum {string}
 */

export const ApiErrorOneOf7 = {
    InvalidBwToken: 'InvalidBwToken'
} as const;

export type ApiErrorOneOf7 = typeof ApiErrorOneOf7[keyof typeof ApiErrorOneOf7];


/**
 * 
 * @export
 * @enum {string}
 */

export const ApiErrorOneOf8 = {
    InvalidLandingId: 'InvalidLandingId'
} as const;

export type ApiErrorOneOf8 = typeof ApiErrorOneOf8[keyof typeof ApiErrorOneOf8];


/**
 * 
 * @export
 * @interface ApiErrorOneOf9
 */
export interface ApiErrorOneOf9 {
    /**
     * 
     * @type {number}
     * @memberof ApiErrorOneOf9
     */
    'InvalidSpeciesGroupId': number;
}
/**
 * 
 * @export
 * @interface ApiErrorOneOfStartAfterEnd
 */
export interface ApiErrorOneOfStartAfterEnd {
    /**
     * 
     * @type {string}
     * @memberof ApiErrorOneOfStartAfterEnd
     */
    'end': string;
    /**
     * 
     * @type {string}
     * @memberof ApiErrorOneOfStartAfterEnd
     */
    'start': string;
}
/**
 * 
 * @export
 * @interface Catch
 */
export interface Catch {
    /**
     * 
     * @type {number}
     * @memberof Catch
     */
    'grossWeight': number;
    /**
     * 
     * @type {number}
     * @memberof Catch
     */
    'livingWeight': number;
    /**
     * 
     * @type {Quality}
     * @memberof Catch
     */
    'productQualityId': Quality;
    /**
     * 
     * @type {string}
     * @memberof Catch
     */
    'productQualityName': string;
    /**
     * 
     * @type {number}
     * @memberof Catch
     */
    'productWeight': number;
    /**
     * 
     * @type {number}
     * @memberof Catch
     */
    'speciesFiskeridirId': number;
}


/**
 * 
 * @export
 * @interface CurrentTrip
 */
export interface CurrentTrip {
    /**
     * 
     * @type {string}
     * @memberof CurrentTrip
     */
    'departure': string;
    /**
     * 
     * @type {Array<FishingFacility>}
     * @memberof CurrentTrip
     */
    'fishingFacilities': Array<FishingFacility>;
    /**
     * 
     * @type {Array<TripHaul>}
     * @memberof CurrentTrip
     */
    'hauls': Array<TripHaul>;
    /**
     * 
     * @type {number}
     * @memberof CurrentTrip
     */
    'targetSpeciesFiskeridirId'?: number | null;
}
/**
 * 
 * @export
 * @interface Delivery
 */
export interface Delivery {
    /**
     * 
     * @type {Array<Catch>}
     * @memberof Delivery
     */
    'delivered': Array<Catch>;
    /**
     * 
     * @type {number}
     * @memberof Delivery
     */
    'totalGrossWeight': number;
    /**
     * 
     * @type {number}
     * @memberof Delivery
     */
    'totalLivingWeight': number;
    /**
     * 
     * @type {number}
     * @memberof Delivery
     */
    'totalProductWeight': number;
}
/**
 * 
 * @export
 * @interface DeliveryPoint
 */
export interface DeliveryPoint {
    /**
     * 
     * @type {string}
     * @memberof DeliveryPoint
     */
    'address'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DeliveryPoint
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof DeliveryPoint
     */
    'latitude'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof DeliveryPoint
     */
    'longitude'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof DeliveryPoint
     */
    'name'?: string | null;
}
/**
 * 
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
    /**
     * 
     * @type {string}
     * @memberof ErrorResponse
     */
    'description': string;
    /**
     * 
     * @type {ApiError}
     * @memberof ErrorResponse
     */
    'error': ApiError;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const FishingFacilitiesSorting = {
    Setup: 'Setup',
    Removed: 'Removed',
    LastChanged: 'LastChanged'
} as const;

export type FishingFacilitiesSorting = typeof FishingFacilitiesSorting[keyof typeof FishingFacilitiesSorting];


/**
 * 
 * @export
 * @interface FishingFacility
 */
export interface FishingFacility {
    /**
     * 
     * @type {string}
     * @memberof FishingFacility
     */
    'barentswatchVesselId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FishingFacility
     */
    'callSign'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FishingFacility
     */
    'comment'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FishingFacility
     */
    'contactEmail'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FishingFacility
     */
    'contactPhone'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof FishingFacility
     */
    'fiskeridirVesselId'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof FishingFacility
     */
    'geometryWkt': string;
    /**
     * 
     * @type {number}
     * @memberof FishingFacility
     */
    'imo'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof FishingFacility
     */
    'lastChanged': string;
    /**
     * 
     * @type {number}
     * @memberof FishingFacility
     */
    'mmsi'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof FishingFacility
     */
    'regNum'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FishingFacility
     */
    'removedProcessedTimestamp'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FishingFacility
     */
    'removedTimestamp'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FishingFacility
     */
    'sbrRegNum'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FishingFacility
     */
    'setupProcessedTimestamp'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FishingFacility
     */
    'setupTimestamp': string;
    /**
     * 
     * @type {string}
     * @memberof FishingFacility
     */
    'source'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FishingFacility
     */
    'toolColor'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof FishingFacility
     */
    'toolCount'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof FishingFacility
     */
    'toolId': string;
    /**
     * 
     * @type {FishingFacilityToolType}
     * @memberof FishingFacility
     */
    'toolType': FishingFacilityToolType;
    /**
     * 
     * @type {string}
     * @memberof FishingFacility
     */
    'toolTypeName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FishingFacility
     */
    'vesselName'?: string | null;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const FishingFacilityToolType = {
    Undefined: 'Undefined',
    Crabpot: 'Crabpot',
    Danpurseine: 'Danpurseine',
    Nets: 'Nets',
    Longline: 'Longline',
    Generic: 'Generic',
    Sensorbuoy: 'Sensorbuoy',
    Sensorcable: 'Sensorcable',
    Unknown: 'Unknown',
    Seismic: 'Seismic',
    Mooring: 'Mooring'
} as const;

export type FishingFacilityToolType = typeof FishingFacilityToolType[keyof typeof FishingFacilityToolType];


/**
 * 
 * @export
 * @interface FishingSpotPrediction
 */
export interface FishingSpotPrediction {
    /**
     * 
     * @type {string}
     * @memberof FishingSpotPrediction
     */
    'date': string;
    /**
     * 
     * @type {number}
     * @memberof FishingSpotPrediction
     */
    'latitude': number;
    /**
     * 
     * @type {number}
     * @memberof FishingSpotPrediction
     */
    'longitude': number;
    /**
     * 
     * @type {SpeciesGroup}
     * @memberof FishingSpotPrediction
     */
    'speciesGroupId': SpeciesGroup;
}


/**
 * 
 * @export
 * @interface FishingWeightPrediction
 */
export interface FishingWeightPrediction {
    /**
     * 
     * @type {string}
     * @memberof FishingWeightPrediction
     */
    'catchLocationId': string;
    /**
     * 
     * @type {string}
     * @memberof FishingWeightPrediction
     */
    'date': string;
    /**
     * 
     * @type {SpeciesGroup}
     * @memberof FishingWeightPrediction
     */
    'speciesGroupId': SpeciesGroup;
    /**
     * 
     * @type {number}
     * @memberof FishingWeightPrediction
     */
    'weight': number;
}


/**
 * 
 * @export
 * @interface FiskeridirVessel
 */
export interface FiskeridirVessel {
    /**
     * 
     * @type {number}
     * @memberof FiskeridirVessel
     */
    'buildingYear'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof FiskeridirVessel
     */
    'callSign': string;
    /**
     * 
     * @type {number}
     * @memberof FiskeridirVessel
     */
    'engineBuildingYear'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof FiskeridirVessel
     */
    'enginePower'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof FiskeridirVessel
     */
    'grossTonnage1969'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof FiskeridirVessel
     */
    'grossTonnageOther'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof FiskeridirVessel
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof FiskeridirVessel
     */
    'length'?: number | null;
    /**
     * 
     * @type {VesselLengthGroup}
     * @memberof FiskeridirVessel
     */
    'lengthGroupId': VesselLengthGroup;
    /**
     * 
     * @type {string}
     * @memberof FiskeridirVessel
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FiskeridirVessel
     */
    'nationGroupId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FiskeridirVessel
     */
    'nationId'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof FiskeridirVessel
     */
    'norwegianCountyId'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof FiskeridirVessel
     */
    'norwegianMunicipalityId'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof FiskeridirVessel
     */
    'owner'?: string | null;
    /**
     * 
     * @type {Array<RegisterVesselOwner>}
     * @memberof FiskeridirVessel
     */
    'owners'?: Array<RegisterVesselOwner> | null;
    /**
     * 
     * @type {number}
     * @memberof FiskeridirVessel
     */
    'rebuildingYear'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof FiskeridirVessel
     */
    'registrationId'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof FiskeridirVessel
     */
    'vesselTypeId'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof FiskeridirVessel
     */
    'width'?: number | null;
}


/**
 * Gear code definitions from Fiskedirektoratet.
 * @export
 * @enum {string}
 */

export const Gear = {
    Unknown: 'Unknown',
    UndefinedSeine: 'UndefinedSeine',
    PurseSeine: 'PurseSeine',
    BeachSeine: 'BeachSeine',
    PurseSeineWithLight: 'PurseSeineWithLight',
    BeachSeineWithLight: 'BeachSeineWithLight',
    UndefinedNet: 'UndefinedNet',
    DriftNet: 'DriftNet',
    GillNet: 'GillNet',
    UndefinedHookGear: 'UndefinedHookGear',
    FloatingLine: 'FloatingLine',
    OtherLines: 'OtherLines',
    Jig: 'Jig',
    DorgHarpSnik: 'DorgHarpSnik',
    AutoLine: 'AutoLine',
    UndefinedLobsterTrapAndFykeNets: 'UndefinedLobsterTrapAndFykeNets',
    FykeNets: 'FykeNets',
    LobsterTraps: 'LobsterTraps',
    WedgeSeine: 'WedgeSeine',
    OceanLobsterTraps: 'OceanLobsterTraps',
    HookNet: 'HookNet',
    UndefinedTrawling: 'UndefinedTrawling',
    BottomTrawl: 'BottomTrawl',
    BottomTrawlPair: 'BottomTrawlPair',
    MidwaterTrawl: 'MidwaterTrawl',
    MidwaterTrawlPair: 'MidwaterTrawlPair',
    ShrimpTrawl: 'ShrimpTrawl',
    BeamTrawl: 'BeamTrawl',
    CrayfishTrawl: 'CrayfishTrawl',
    DoubleTrawl: 'DoubleTrawl',
    TripleTrawl: 'TripleTrawl',
    DanishSeine: 'DanishSeine',
    Harpoon: 'Harpoon',
    BaskingSharkWhaleCannon: 'BaskingSharkWhaleCannon',
    BigHarpoon: 'BigHarpoon',
    Rifle: 'Rifle',
    Other: 'Other',
    ShellScrape: 'ShellScrape',
    HandNet: 'HandNet',
    KelpTrawl: 'KelpTrawl',
    SeaweedCutter: 'SeaweedCutter',
    HandPicking: 'HandPicking',
    ShellSucker: 'ShellSucker',
    FishFarming: 'FishFarming',
    Unspecified: 'Unspecified'
} as const;

export type Gear = typeof Gear[keyof typeof Gear];


/**
 * 
 * @export
 * @interface GearDetailed
 */
export interface GearDetailed {
    /**
     * 
     * @type {Gear}
     * @memberof GearDetailed
     */
    'id': Gear;
    /**
     * 
     * @type {string}
     * @memberof GearDetailed
     */
    'name': string;
}


/**
 * GearGroup code definitions from Fiskedirektoratet.
 * @export
 * @enum {string}
 */

export const GearGroup = {
    Unknown: 'Unknown',
    Seine: 'Seine',
    Net: 'Net',
    HookGear: 'HookGear',
    LobsterTrapAndFykeNets: 'LobsterTrapAndFykeNets',
    Trawl: 'Trawl',
    DanishSeine: 'DanishSeine',
    HarpoonCannon: 'HarpoonCannon',
    OtherGear: 'OtherGear',
    FishFarming: 'FishFarming'
} as const;

export type GearGroup = typeof GearGroup[keyof typeof GearGroup];


/**
 * 
 * @export
 * @interface GearGroupDetailed
 */
export interface GearGroupDetailed {
    /**
     * 
     * @type {GearGroup}
     * @memberof GearGroupDetailed
     */
    'id': GearGroup;
    /**
     * 
     * @type {string}
     * @memberof GearGroupDetailed
     */
    'name': string;
}


/**
 * 
 * @export
 * @interface GearMainGroupDetailed
 */
export interface GearMainGroupDetailed {
    /**
     * 
     * @type {MainGearGroup}
     * @memberof GearMainGroupDetailed
     */
    'id': MainGearGroup;
    /**
     * 
     * @type {string}
     * @memberof GearMainGroupDetailed
     */
    'name': string;
}


/**
 * 
 * @export
 * @interface Haul
 */
export interface Haul {
    /**
     * 
     * @type {number}
     * @memberof Haul
     */
    'airPressureAtSeaLevel'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof Haul
     */
    'airTemperature2m'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof Haul
     */
    'cloudAreaFraction'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof Haul
     */
    'precipitationAmount'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof Haul
     */
    'relativeHumidity2m'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof Haul
     */
    'windDirection10m'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof Haul
     */
    'windSpeed10m'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof Haul
     */
    'oceanClimateDepth'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof Haul
     */
    'salinity'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof Haul
     */
    'seaFloorDepth'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof Haul
     */
    'waterDirection'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof Haul
     */
    'waterSpeed'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof Haul
     */
    'waterTemperature'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof Haul
     */
    'catchLocationStart'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof Haul
     */
    'catchLocations'?: Array<string> | null;
    /**
     * 
     * @type {Array<HaulCatch>}
     * @memberof Haul
     */
    'catches': Array<HaulCatch>;
    /**
     * 
     * @type {number}
     * @memberof Haul
     */
    'duration': number;
    /**
     * 
     * @type {string}
     * @memberof Haul
     */
    'ersActivityId': string;
    /**
     * 
     * @type {number}
     * @memberof Haul
     */
    'fiskeridirVesselId'?: number | null;
    /**
     * 
     * @type {GearGroup}
     * @memberof Haul
     */
    'gearGroupId': GearGroup;
    /**
     * 
     * @type {Gear}
     * @memberof Haul
     */
    'gearId': Gear;
    /**
     * 
     * @type {number}
     * @memberof Haul
     */
    'haulDistance'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof Haul
     */
    'haulId': number;
    /**
     * 
     * @type {number}
     * @memberof Haul
     */
    'oceanDepthEnd': number;
    /**
     * 
     * @type {number}
     * @memberof Haul
     */
    'oceanDepthStart': number;
    /**
     * 
     * @type {number}
     * @memberof Haul
     */
    'quotaTypeId': number;
    /**
     * 
     * @type {number}
     * @memberof Haul
     */
    'startLatitude': number;
    /**
     * 
     * @type {number}
     * @memberof Haul
     */
    'startLongitude': number;
    /**
     * 
     * @type {string}
     * @memberof Haul
     */
    'startTimestamp': string;
    /**
     * 
     * @type {number}
     * @memberof Haul
     */
    'stopLatitude': number;
    /**
     * 
     * @type {number}
     * @memberof Haul
     */
    'stopLongitude': number;
    /**
     * 
     * @type {string}
     * @memberof Haul
     */
    'stopTimestamp': string;
    /**
     * 
     * @type {number}
     * @memberof Haul
     */
    'totalLivingWeight': number;
    /**
     * 
     * @type {string}
     * @memberof Haul
     */
    'vesselCallSign'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Haul
     */
    'vesselCallSignErs': string;
    /**
     * 
     * @type {number}
     * @memberof Haul
     */
    'vesselLength': number;
    /**
     * 
     * @type {number}
     * @memberof Haul
     */
    'vesselLengthGroup': number;
    /**
     * 
     * @type {string}
     * @memberof Haul
     */
    'vesselName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Haul
     */
    'vesselNameErs'?: string | null;
    /**
     * 
     * @type {Array<WhaleCatch>}
     * @memberof Haul
     */
    'whaleCatches': Array<WhaleCatch>;
}


/**
 * 
 * @export
 * @interface HaulAllOf
 */
export interface HaulAllOf {
    /**
     * 
     * @type {string}
     * @memberof HaulAllOf
     */
    'catchLocationStart'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof HaulAllOf
     */
    'catchLocations'?: Array<string> | null;
    /**
     * 
     * @type {Array<HaulCatch>}
     * @memberof HaulAllOf
     */
    'catches': Array<HaulCatch>;
    /**
     * 
     * @type {number}
     * @memberof HaulAllOf
     */
    'duration': number;
    /**
     * 
     * @type {string}
     * @memberof HaulAllOf
     */
    'ersActivityId': string;
    /**
     * 
     * @type {number}
     * @memberof HaulAllOf
     */
    'fiskeridirVesselId'?: number | null;
    /**
     * 
     * @type {GearGroup}
     * @memberof HaulAllOf
     */
    'gearGroupId': GearGroup;
    /**
     * 
     * @type {Gear}
     * @memberof HaulAllOf
     */
    'gearId': Gear;
    /**
     * 
     * @type {number}
     * @memberof HaulAllOf
     */
    'haulDistance'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof HaulAllOf
     */
    'haulId': number;
    /**
     * 
     * @type {number}
     * @memberof HaulAllOf
     */
    'oceanDepthEnd': number;
    /**
     * 
     * @type {number}
     * @memberof HaulAllOf
     */
    'oceanDepthStart': number;
    /**
     * 
     * @type {number}
     * @memberof HaulAllOf
     */
    'quotaTypeId': number;
    /**
     * 
     * @type {number}
     * @memberof HaulAllOf
     */
    'startLatitude': number;
    /**
     * 
     * @type {number}
     * @memberof HaulAllOf
     */
    'startLongitude': number;
    /**
     * 
     * @type {string}
     * @memberof HaulAllOf
     */
    'startTimestamp': string;
    /**
     * 
     * @type {number}
     * @memberof HaulAllOf
     */
    'stopLatitude': number;
    /**
     * 
     * @type {number}
     * @memberof HaulAllOf
     */
    'stopLongitude': number;
    /**
     * 
     * @type {string}
     * @memberof HaulAllOf
     */
    'stopTimestamp': string;
    /**
     * 
     * @type {number}
     * @memberof HaulAllOf
     */
    'totalLivingWeight': number;
    /**
     * 
     * @type {string}
     * @memberof HaulAllOf
     */
    'vesselCallSign'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof HaulAllOf
     */
    'vesselCallSignErs': string;
    /**
     * 
     * @type {number}
     * @memberof HaulAllOf
     */
    'vesselLength': number;
    /**
     * 
     * @type {number}
     * @memberof HaulAllOf
     */
    'vesselLengthGroup': number;
    /**
     * 
     * @type {string}
     * @memberof HaulAllOf
     */
    'vesselName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof HaulAllOf
     */
    'vesselNameErs'?: string | null;
    /**
     * 
     * @type {Array<WhaleCatch>}
     * @memberof HaulAllOf
     */
    'whaleCatches': Array<WhaleCatch>;
}


/**
 * 
 * @export
 * @interface HaulCatch
 */
export interface HaulCatch {
    /**
     * 
     * @type {number}
     * @memberof HaulCatch
     */
    'livingWeight': number;
    /**
     * 
     * @type {number}
     * @memberof HaulCatch
     */
    'speciesFiskeridirId': number;
    /**
     * 
     * @type {SpeciesGroup}
     * @memberof HaulCatch
     */
    'speciesGroupId': SpeciesGroup;
}


/**
 * 
 * @export
 * @interface HaulOceanClimate
 */
export interface HaulOceanClimate {
    /**
     * 
     * @type {number}
     * @memberof HaulOceanClimate
     */
    'oceanClimateDepth'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof HaulOceanClimate
     */
    'salinity'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof HaulOceanClimate
     */
    'seaFloorDepth'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof HaulOceanClimate
     */
    'waterDirection'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof HaulOceanClimate
     */
    'waterSpeed'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof HaulOceanClimate
     */
    'waterTemperature'?: number | null;
}
/**
 * 
 * @export
 * @interface HaulWeather
 */
export interface HaulWeather {
    /**
     * 
     * @type {number}
     * @memberof HaulWeather
     */
    'airPressureAtSeaLevel'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof HaulWeather
     */
    'airTemperature2m'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof HaulWeather
     */
    'cloudAreaFraction'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof HaulWeather
     */
    'precipitationAmount'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof HaulWeather
     */
    'relativeHumidity2m'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof HaulWeather
     */
    'windDirection10m'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof HaulWeather
     */
    'windSpeed10m'?: number | null;
}
/**
 * 
 * @export
 * @interface HaulsMatrix
 */
export interface HaulsMatrix {
    /**
     * 
     * @type {Array<number>}
     * @memberof HaulsMatrix
     */
    'dates': Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof HaulsMatrix
     */
    'gearGroup': Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof HaulsMatrix
     */
    'lengthGroup': Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof HaulsMatrix
     */
    'speciesGroup': Array<number>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const HaulsSorting = {
    StartDate: 'StartDate',
    StopDate: 'StopDate',
    Weight: 'Weight'
} as const;

export type HaulsSorting = typeof HaulsSorting[keyof typeof HaulsSorting];


/**
 * 
 * @export
 * @interface Landing
 */
export interface Landing {
    /**
     * 
     * @type {string}
     * @memberof Landing
     */
    'catchLocation'?: string | null;
    /**
     * 
     * @type {Array<LandingCatch>}
     * @memberof Landing
     */
    'catches': Array<LandingCatch>;
    /**
     * 
     * @type {string}
     * @memberof Landing
     */
    'deliveryPointId'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Landing
     */
    'fiskeridirVesselId'?: number | null;
    /**
     * 
     * @type {GearGroup}
     * @memberof Landing
     */
    'gearGroupId': GearGroup;
    /**
     * 
     * @type {Gear}
     * @memberof Landing
     */
    'gearId': Gear;
    /**
     * 
     * @type {string}
     * @memberof Landing
     */
    'landingId': string;
    /**
     * 
     * @type {string}
     * @memberof Landing
     */
    'landingTimestamp': string;
    /**
     * 
     * @type {number}
     * @memberof Landing
     */
    'totalGrossWeight': number;
    /**
     * 
     * @type {number}
     * @memberof Landing
     */
    'totalLivingWeight': number;
    /**
     * 
     * @type {number}
     * @memberof Landing
     */
    'totalProductWeight': number;
    /**
     * 
     * @type {string}
     * @memberof Landing
     */
    'vesselCallSign'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Landing
     */
    'vesselLength'?: number | null;
    /**
     * 
     * @type {VesselLengthGroup}
     * @memberof Landing
     */
    'vesselLengthGroup': VesselLengthGroup;
    /**
     * 
     * @type {string}
     * @memberof Landing
     */
    'vesselName'?: string | null;
}


/**
 * 
 * @export
 * @interface LandingCatch
 */
export interface LandingCatch {
    /**
     * 
     * @type {number}
     * @memberof LandingCatch
     */
    'grossWeight': number;
    /**
     * 
     * @type {number}
     * @memberof LandingCatch
     */
    'livingWeight': number;
    /**
     * 
     * @type {number}
     * @memberof LandingCatch
     */
    'productWeight': number;
    /**
     * 
     * @type {number}
     * @memberof LandingCatch
     */
    'speciesFiskeridirId': number;
    /**
     * 
     * @type {SpeciesGroup}
     * @memberof LandingCatch
     */
    'speciesGroupId': SpeciesGroup;
}


/**
 * 
 * @export
 * @interface LandingMatrix
 */
export interface LandingMatrix {
    /**
     * 
     * @type {Array<number>}
     * @memberof LandingMatrix
     */
    'dates': Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof LandingMatrix
     */
    'gearGroup': Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof LandingMatrix
     */
    'lengthGroup': Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof LandingMatrix
     */
    'speciesGroup': Array<number>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const LandingsSorting = {
    LandingTimestamp: 'LandingTimestamp',
    LivingWeight: 'LivingWeight'
} as const;

export type LandingsSorting = typeof LandingsSorting[keyof typeof LandingsSorting];


/**
 * MainGearGroup code definitions from Fiskedirektoratet.
 * @export
 * @enum {string}
 */

export const MainGearGroup = {
    Unknown: 'Unknown',
    Trawl: 'Trawl',
    Seine: 'Seine',
    Conventional: 'Conventional',
    Other: 'Other'
} as const;

export type MainGearGroup = typeof MainGearGroup[keyof typeof MainGearGroup];


/**
 * 
 * @export
 * @enum {string}
 */

export const ModelId = {
    Spot: 'Spot',
    Weight: 'Weight',
    WeightWeather: 'WeightWeather',
    SpotWeather: 'SpotWeather'
} as const;

export type ModelId = typeof ModelId[keyof typeof ModelId];


/**
 * 
 * @export
 * @enum {string}
 */

export const NavigationStatus = {
    UnderWayUsingEngine: 'UnderWayUsingEngine',
    AtAnchor: 'AtAnchor',
    NotUnderCommand: 'NotUnderCommand',
    RestrictedManoeuverability: 'RestrictedManoeuverability',
    ConstrainedByDraught: 'ConstrainedByDraught',
    Moored: 'Moored',
    Aground: 'Aground',
    EngagedInFishing: 'EngagedInFishing',
    UnderWaySailing: 'UnderWaySailing',
    Reserved9: 'Reserved9',
    Reserved10: 'Reserved10',
    Reserved11: 'Reserved11',
    Reserved12: 'Reserved12',
    Reserved13: 'Reserved13',
    AisSartIsActive: 'AisSartIsActive',
    NotDefined: 'NotDefined'
} as const;

export type NavigationStatus = typeof NavigationStatus[keyof typeof NavigationStatus];


/**
 * 
 * @export
 * @enum {string}
 */

export const Ordering = {
    Asc: 'Asc',
    Desc: 'Desc'
} as const;

export type Ordering = typeof Ordering[keyof typeof Ordering];


/**
 * 
 * @export
 * @enum {string}
 */

export const Quality = {
    Extra: 'Extra',
    Prima: 'Prima',
    Superior: 'Superior',
    A: 'A',
    Blank: 'Blank',
    B: 'B',
    Sekunda: 'Sekunda',
    Africa: 'Africa',
    FrostDamagedFish: 'FrostDamagedFish',
    Yellow: 'Yellow',
    ProductionRoe: 'ProductionRoe',
    CrackedCrab: 'CrackedCrab',
    WetCrab: 'WetCrab',
    WrongCut: 'WrongCut',
    Injured: 'Injured',
    Offal: 'Offal',
    Wrek: 'Wrek',
    Unspecified: 'Unspecified'
} as const;

export type Quality = typeof Quality[keyof typeof Quality];


/**
 * 
 * @export
 * @enum {string}
 */

export const RegisterVesselEntityType = {
    Company: 'COMPANY',
    Person: 'PERSON'
} as const;

export type RegisterVesselEntityType = typeof RegisterVesselEntityType[keyof typeof RegisterVesselEntityType];


/**
 * 
 * @export
 * @interface RegisterVesselOwner
 */
export interface RegisterVesselOwner {
    /**
     * 
     * @type {string}
     * @memberof RegisterVesselOwner
     */
    'city'?: string | null;
    /**
     * 
     * @type {RegisterVesselEntityType}
     * @memberof RegisterVesselOwner
     */
    'entityType': RegisterVesselEntityType;
    /**
     * 
     * @type {number}
     * @memberof RegisterVesselOwner
     */
    'id'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof RegisterVesselOwner
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof RegisterVesselOwner
     */
    'postalCode': number;
}


/**
 * 
 * @export
 * @interface Species
 */
export interface Species {
    /**
     * 
     * @type {number}
     * @memberof Species
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof Species
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface SpeciesFao
 */
export interface SpeciesFao {
    /**
     * 
     * @type {string}
     * @memberof SpeciesFao
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof SpeciesFao
     */
    'name'?: string | null;
}
/**
 * 
 * @export
 * @interface SpeciesFiskeridir
 */
export interface SpeciesFiskeridir {
    /**
     * 
     * @type {number}
     * @memberof SpeciesFiskeridir
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof SpeciesFiskeridir
     */
    'name'?: string | null;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const SpeciesGroup = {
    Unknown: 'Unknown',
    Capelin: 'Capelin',
    NorwegianSpringSpawningHerring: 'NorwegianSpringSpawningHerring',
    OtherHerring: 'OtherHerring',
    Mackerel: 'Mackerel',
    BlueWhiting: 'BlueWhiting',
    NorwayPout: 'NorwayPout',
    Sandeels: 'Sandeels',
    Argentines: 'Argentines',
    EuropeanSpratSea: 'EuropeanSpratSea',
    EuropeanSpratCoast: 'EuropeanSpratCoast',
    MesopelagicFish: 'MesopelagicFish',
    TunaAndTunaishSpecies: 'TunaAndTunaishSpecies',
    OtherPelagicFish: 'OtherPelagicFish',
    AtlanticCod: 'AtlanticCod',
    Haddock: 'Haddock',
    Saithe: 'Saithe',
    Gadiformes: 'Gadiformes',
    GreenlandHalibut: 'GreenlandHalibut',
    GoldenRedfish: 'GoldenRedfish',
    Wrasse: 'Wrasse',
    Wolffishes: 'Wolffishes',
    FlatFishOtherBottomFishAndDeepseaFish: 'FlatFishOtherBottomFishAndDeepseaFish',
    SharkFish: 'SharkFish',
    SkatesAndOtherChondrichthyes: 'SkatesAndOtherChondrichthyes',
    QueenCrab: 'QueenCrab',
    EdibleCrab: 'EdibleCrab',
    RedKingCrab: 'RedKingCrab',
    RedKingCrabOther: 'RedKingCrabOther',
    NorthernPrawn: 'NorthernPrawn',
    AntarcticKrill: 'AntarcticKrill',
    CalanusFinmarchicus: 'CalanusFinmarchicus',
    OtherShellfishMolluscaAndEchinoderm: 'OtherShellfishMolluscaAndEchinoderm',
    BrownSeaweed: 'BrownSeaweed',
    OtherSeaweed: 'OtherSeaweed',
    FreshWaterFish: 'FreshWaterFish',
    FishFarming: 'FishFarming',
    MarineMammals: 'MarineMammals',
    Other: 'Other'
} as const;

export type SpeciesGroup = typeof SpeciesGroup[keyof typeof SpeciesGroup];


/**
 * 
 * @export
 * @interface SpeciesGroupDetailed
 */
export interface SpeciesGroupDetailed {
    /**
     * 
     * @type {SpeciesGroup}
     * @memberof SpeciesGroupDetailed
     */
    'id': SpeciesGroup;
    /**
     * 
     * @type {string}
     * @memberof SpeciesGroupDetailed
     */
    'name': string;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const SpeciesMainGroup = {
    Unknown: 'Unknown',
    PelagicFish: 'PelagicFish',
    CodAndCodishFish: 'CodAndCodishFish',
    FlatFishOtherBottomFishAndDeepseaFish: 'FlatFishOtherBottomFishAndDeepseaFish',
    ChondrichthyesSharkFishSkatesRaysAndRabbitFish: 'ChondrichthyesSharkFishSkatesRaysAndRabbitFish',
    ShellfishMolluscaAndEchinoderm: 'ShellfishMolluscaAndEchinoderm',
    Seaweed: 'Seaweed',
    FishFarmingFreshWaterFishAndMarineMammals: 'FishFarmingFreshWaterFishAndMarineMammals'
} as const;

export type SpeciesMainGroup = typeof SpeciesMainGroup[keyof typeof SpeciesMainGroup];


/**
 * 
 * @export
 * @interface SpeciesMainGroupDetailed
 */
export interface SpeciesMainGroupDetailed {
    /**
     * 
     * @type {SpeciesMainGroup}
     * @memberof SpeciesMainGroupDetailed
     */
    'id': SpeciesMainGroup;
    /**
     * 
     * @type {string}
     * @memberof SpeciesMainGroupDetailed
     */
    'name': string;
}


/**
 * 
 * @export
 * @interface Trip
 */
export interface Trip {
    /**
     * 
     * @type {Delivery}
     * @memberof Trip
     */
    'delivery': Delivery;
    /**
     * 
     * @type {Array<string>}
     * @memberof Trip
     */
    'deliveryPointIds': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Trip
     */
    'end': string;
    /**
     * 
     * @type {string}
     * @memberof Trip
     */
    'endPortId'?: string | null;
    /**
     * 
     * @type {Array<VesselEvent>}
     * @memberof Trip
     */
    'events': Array<VesselEvent>;
    /**
     * 
     * @type {Array<FishingFacility>}
     * @memberof Trip
     */
    'fishingFacilities': Array<FishingFacility>;
    /**
     * 
     * @type {number}
     * @memberof Trip
     */
    'fiskeridirVesselId': number;
    /**
     * 
     * @type {Array<Gear>}
     * @memberof Trip
     */
    'gearIds': Array<Gear>;
    /**
     * 
     * @type {Array<TripHaul>}
     * @memberof Trip
     */
    'hauls': Array<TripHaul>;
    /**
     * 
     * @type {string}
     * @memberof Trip
     */
    'landingCoverageEnd': string;
    /**
     * 
     * @type {string}
     * @memberof Trip
     */
    'landingCoverageStart': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Trip
     */
    'landingIds': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Trip
     */
    'mostRecentDeliveryDate'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Trip
     */
    'numDeliveries': number;
    /**
     * 
     * @type {string}
     * @memberof Trip
     */
    'start': string;
    /**
     * 
     * @type {string}
     * @memberof Trip
     */
    'startPortId'?: string | null;
    /**
     * 
     * @type {TripAssemblerId}
     * @memberof Trip
     */
    'tripAssemblerId': TripAssemblerId;
    /**
     * 
     * @type {number}
     * @memberof Trip
     */
    'tripId': number;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const TripAssemblerId = {
    Landings: 'Landings',
    Ers: 'Ers'
} as const;

export type TripAssemblerId = typeof TripAssemblerId[keyof typeof TripAssemblerId];


/**
 * 
 * @export
 * @interface TripHaul
 */
export interface TripHaul {
    /**
     * 
     * @type {Array<HaulCatch>}
     * @memberof TripHaul
     */
    'catches': Array<HaulCatch>;
    /**
     * 
     * @type {number}
     * @memberof TripHaul
     */
    'duration': number;
    /**
     * 
     * @type {string}
     * @memberof TripHaul
     */
    'ersActivityId': string;
    /**
     * 
     * @type {number}
     * @memberof TripHaul
     */
    'fiskeridirVesselId'?: number | null;
    /**
     * 
     * @type {GearGroup}
     * @memberof TripHaul
     */
    'gearGroupId': GearGroup;
    /**
     * 
     * @type {Gear}
     * @memberof TripHaul
     */
    'gearId': Gear;
    /**
     * 
     * @type {number}
     * @memberof TripHaul
     */
    'haulDistance'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof TripHaul
     */
    'haulId': number;
    /**
     * 
     * @type {number}
     * @memberof TripHaul
     */
    'startLatitude': number;
    /**
     * 
     * @type {number}
     * @memberof TripHaul
     */
    'startLongitude': number;
    /**
     * 
     * @type {string}
     * @memberof TripHaul
     */
    'startTimestamp': string;
    /**
     * 
     * @type {number}
     * @memberof TripHaul
     */
    'stopLatitude': number;
    /**
     * 
     * @type {number}
     * @memberof TripHaul
     */
    'stopLongitude': number;
    /**
     * 
     * @type {string}
     * @memberof TripHaul
     */
    'stopTimestamp': string;
    /**
     * 
     * @type {number}
     * @memberof TripHaul
     */
    'totalLivingWeight': number;
    /**
     * 
     * @type {Array<WhaleCatch>}
     * @memberof TripHaul
     */
    'whaleCatches': Array<WhaleCatch>;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const TripPositionLayerId = {
    UnrealisticSpeed: 'UnrealisticSpeed',
    Cluster: 'Cluster'
} as const;

export type TripPositionLayerId = typeof TripPositionLayerId[keyof typeof TripPositionLayerId];


/**
 * 
 * @export
 * @enum {string}
 */

export const TripSorting = {
    StopDate: 'StopDate',
    Weight: 'Weight'
} as const;

export type TripSorting = typeof TripSorting[keyof typeof TripSorting];


/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {Array<number>}
     * @memberof User
     */
    'following': Array<number>;
}
/**
 * 
 * @export
 * @interface Vessel
 */
export interface Vessel {
    /**
     * 
     * @type {AisVessel}
     * @memberof Vessel
     */
    'ais'?: AisVessel | null;
    /**
     * 
     * @type {number}
     * @memberof Vessel
     */
    'fishCaughtPerHour'?: number | null;
    /**
     * 
     * @type {FiskeridirVessel}
     * @memberof Vessel
     */
    'fiskeridir': FiskeridirVessel;
    /**
     * 
     * @type {Array<GearGroup>}
     * @memberof Vessel
     */
    'gearGroups': Array<GearGroup>;
    /**
     * 
     * @type {Array<SpeciesGroup>}
     * @memberof Vessel
     */
    'speciesGroups': Array<SpeciesGroup>;
}
/**
 * 
 * @export
 * @interface VesselEvent
 */
export interface VesselEvent {
    /**
     * 
     * @type {number}
     * @memberof VesselEvent
     */
    'eventId': number;
    /**
     * 
     * @type {string}
     * @memberof VesselEvent
     */
    'eventName': string;
    /**
     * 
     * @type {VesselEventType}
     * @memberof VesselEvent
     */
    'eventType': VesselEventType;
    /**
     * 
     * @type {string}
     * @memberof VesselEvent
     */
    'occurenceTimestamp'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof VesselEvent
     */
    'reportTimestamp': string;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const VesselEventType = {
    Landing: 'Landing',
    ErsDca: 'ErsDca',
    ErsPor: 'ErsPor',
    ErsDep: 'ErsDep',
    ErsTra: 'ErsTra',
    Haul: 'Haul'
} as const;

export type VesselEventType = typeof VesselEventType[keyof typeof VesselEventType];


/**
 * 
 * @export
 * @enum {string}
 */

export const VesselLengthGroup = {
    Unknown: 'Unknown',
    UnderEleven: 'UnderEleven',
    ElevenToFifteen: 'ElevenToFifteen',
    FifteenToTwentyOne: 'FifteenToTwentyOne',
    TwentyTwoToTwentyEight: 'TwentyTwoToTwentyEight',
    TwentyEightAndAbove: 'TwentyEightAndAbove'
} as const;

export type VesselLengthGroup = typeof VesselLengthGroup[keyof typeof VesselLengthGroup];


/**
 * 
 * @export
 * @interface VmsPosition
 */
export interface VmsPosition {
    /**
     * 
     * @type {number}
     * @memberof VmsPosition
     */
    'course'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof VmsPosition
     */
    'distanceToShore': number;
    /**
     * 
     * @type {number}
     * @memberof VmsPosition
     */
    'lat': number;
    /**
     * 
     * @type {number}
     * @memberof VmsPosition
     */
    'lon': number;
    /**
     * 
     * @type {number}
     * @memberof VmsPosition
     */
    'speed'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof VmsPosition
     */
    'timestamp': string;
}
/**
 * 
 * @export
 * @interface Weather
 */
export interface Weather {
    /**
     * 
     * @type {number}
     * @memberof Weather
     */
    'airPressureAtSeaLevel'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof Weather
     */
    'airTemperature2m'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof Weather
     */
    'altitude': number;
    /**
     * 
     * @type {number}
     * @memberof Weather
     */
    'cloudAreaFraction'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof Weather
     */
    'landAreaFraction': number;
    /**
     * 
     * @type {number}
     * @memberof Weather
     */
    'latitude': number;
    /**
     * 
     * @type {number}
     * @memberof Weather
     */
    'longitude': number;
    /**
     * 
     * @type {number}
     * @memberof Weather
     */
    'precipitationAmount'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof Weather
     */
    'relativeHumidity2m'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof Weather
     */
    'timestamp': string;
    /**
     * 
     * @type {number}
     * @memberof Weather
     */
    'windDirection10m'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof Weather
     */
    'windSpeed10m'?: number | null;
}
/**
 * 
 * @export
 * @interface WeatherLocation
 */
export interface WeatherLocation {
    /**
     * 
     * @type {number}
     * @memberof WeatherLocation
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof WeatherLocation
     */
    'polygon': string;
}
/**
 * 
 * @export
 * @interface WhaleCatch
 */
export interface WhaleCatch {
    /**
     * 
     * @type {number}
     * @memberof WhaleCatch
     */
    'blubberMeasureA'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof WhaleCatch
     */
    'blubberMeasureB'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof WhaleCatch
     */
    'blubberMeasureC'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof WhaleCatch
     */
    'circumference'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof WhaleCatch
     */
    'fetusLength'?: number | null;
    /**
     * 
     * @type {WhaleGender}
     * @memberof WhaleCatch
     */
    'genderId'?: WhaleGender | null;
    /**
     * 
     * @type {string}
     * @memberof WhaleCatch
     */
    'grenadeNumber': string;
    /**
     * 
     * @type {number}
     * @memberof WhaleCatch
     */
    'individualNumber'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof WhaleCatch
     */
    'length'?: number | null;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const WhaleGender = {
    Male: 'Male',
    Female: 'Female'
} as const;

export type WhaleGender = typeof WhaleGender[keyof typeof WhaleGender];



/**
 * V1aisApi - axios parameter creator
 * @export
 */
export const V1aisApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} mmsi 
         * @param {string} [start] 
         * @param {string} [end] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aisTrack: async (mmsi: number, start?: string, end?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mmsi' is not null or undefined
            assertParamExists('aisTrack', 'mmsi', mmsi)
            const localVarPath = `/v1.0/ais_track/{mmsi}`
                .replace(`{${"mmsi"}}`, encodeURIComponent(String(mmsi)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication auth0 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "auth0", ["read:ais:under_15m"], configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = (start as any instanceof Date) ?
                    (start as any).toISOString() :
                    start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = (end as any instanceof Date) ?
                    (end as any).toISOString() :
                    end;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * V1aisApi - functional programming interface
 * @export
 */
export const V1aisApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = V1aisApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} mmsi 
         * @param {string} [start] 
         * @param {string} [end] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async aisTrack(mmsi: number, start?: string, end?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AisPosition>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.aisTrack(mmsi, start, end, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * V1aisApi - factory interface
 * @export
 */
export const V1aisApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = V1aisApiFp(configuration)
    return {
        /**
         * 
         * @param {V1aisApiAisTrackRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aisTrack(requestParameters: V1aisApiAisTrackRequest, options?: AxiosRequestConfig): AxiosPromise<Array<AisPosition>> {
            return localVarFp.aisTrack(requestParameters.mmsi, requestParameters.start, requestParameters.end, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for aisTrack operation in V1aisApi.
 * @export
 * @interface V1aisApiAisTrackRequest
 */
export interface V1aisApiAisTrackRequest {
    /**
     * 
     * @type {number}
     * @memberof V1aisApiAisTrack
     */
    readonly mmsi: number

    /**
     * 
     * @type {string}
     * @memberof V1aisApiAisTrack
     */
    readonly start?: string

    /**
     * 
     * @type {string}
     * @memberof V1aisApiAisTrack
     */
    readonly end?: string
}

/**
 * V1aisApi - object-oriented interface
 * @export
 * @class V1aisApi
 * @extends {BaseAPI}
 */
export class V1aisApi extends BaseAPI {
    /**
     * 
     * @param {V1aisApiAisTrackRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1aisApi
     */
    public aisTrack(requestParameters: V1aisApiAisTrackRequest, options?: AxiosRequestConfig) {
        return V1aisApiFp(this.configuration).aisTrack(requestParameters.mmsi, requestParameters.start, requestParameters.end, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * V1aisVmsApi - axios parameter creator
 * @export
 */
export const V1aisVmsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} [mmsi] 
         * @param {string} [callSign] 
         * @param {number} [tripId] 
         * @param {string} [start] 
         * @param {string} [end] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aisVmsPositions: async (mmsi?: number, callSign?: string, tripId?: number, start?: string, end?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1.0/ais_vms_positions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication auth0 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "auth0", ["read:ais:under_15m"], configuration)

            if (mmsi !== undefined) {
                localVarQueryParameter['mmsi'] = mmsi;
            }

            if (callSign !== undefined) {
                localVarQueryParameter['callSign'] = callSign;
            }

            if (tripId !== undefined) {
                localVarQueryParameter['tripId'] = tripId;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = (start as any instanceof Date) ?
                    (start as any).toISOString() :
                    start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = (end as any instanceof Date) ?
                    (end as any).toISOString() :
                    end;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * V1aisVmsApi - functional programming interface
 * @export
 */
export const V1aisVmsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = V1aisVmsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} [mmsi] 
         * @param {string} [callSign] 
         * @param {number} [tripId] 
         * @param {string} [start] 
         * @param {string} [end] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async aisVmsPositions(mmsi?: number, callSign?: string, tripId?: number, start?: string, end?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AisVmsPosition>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.aisVmsPositions(mmsi, callSign, tripId, start, end, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * V1aisVmsApi - factory interface
 * @export
 */
export const V1aisVmsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = V1aisVmsApiFp(configuration)
    return {
        /**
         * 
         * @param {V1aisVmsApiAisVmsPositionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aisVmsPositions(requestParameters: V1aisVmsApiAisVmsPositionsRequest = {}, options?: AxiosRequestConfig): AxiosPromise<Array<AisVmsPosition>> {
            return localVarFp.aisVmsPositions(requestParameters.mmsi, requestParameters.callSign, requestParameters.tripId, requestParameters.start, requestParameters.end, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for aisVmsPositions operation in V1aisVmsApi.
 * @export
 * @interface V1aisVmsApiAisVmsPositionsRequest
 */
export interface V1aisVmsApiAisVmsPositionsRequest {
    /**
     * 
     * @type {number}
     * @memberof V1aisVmsApiAisVmsPositions
     */
    readonly mmsi?: number

    /**
     * 
     * @type {string}
     * @memberof V1aisVmsApiAisVmsPositions
     */
    readonly callSign?: string

    /**
     * 
     * @type {number}
     * @memberof V1aisVmsApiAisVmsPositions
     */
    readonly tripId?: number

    /**
     * 
     * @type {string}
     * @memberof V1aisVmsApiAisVmsPositions
     */
    readonly start?: string

    /**
     * 
     * @type {string}
     * @memberof V1aisVmsApiAisVmsPositions
     */
    readonly end?: string
}

/**
 * V1aisVmsApi - object-oriented interface
 * @export
 * @class V1aisVmsApi
 * @extends {BaseAPI}
 */
export class V1aisVmsApi extends BaseAPI {
    /**
     * 
     * @param {V1aisVmsApiAisVmsPositionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1aisVmsApi
     */
    public aisVmsPositions(requestParameters: V1aisVmsApiAisVmsPositionsRequest = {}, options?: AxiosRequestConfig) {
        return V1aisVmsApiFp(this.configuration).aisVmsPositions(requestParameters.mmsi, requestParameters.callSign, requestParameters.tripId, requestParameters.start, requestParameters.end, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * V1deliveryPointApi - axios parameter creator
 * @export
 */
export const V1deliveryPointApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deliveryPoints: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1.0/delivery_points`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication auth0 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "auth0", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * V1deliveryPointApi - functional programming interface
 * @export
 */
export const V1deliveryPointApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = V1deliveryPointApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deliveryPoints(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DeliveryPoint>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deliveryPoints(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * V1deliveryPointApi - factory interface
 * @export
 */
export const V1deliveryPointApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = V1deliveryPointApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deliveryPoints(options?: AxiosRequestConfig): AxiosPromise<Array<DeliveryPoint>> {
            return localVarFp.deliveryPoints(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * V1deliveryPointApi - object-oriented interface
 * @export
 * @class V1deliveryPointApi
 * @extends {BaseAPI}
 */
export class V1deliveryPointApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1deliveryPointApi
     */
    public deliveryPoints(options?: AxiosRequestConfig) {
        return V1deliveryPointApiFp(this.configuration).deliveryPoints(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * V1fishingFacilityApi - axios parameter creator
 * @export
 */
export const V1fishingFacilityApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Array<number>} [mmsis] 
         * @param {Array<number>} [fiskeridirVesselIds] 
         * @param {Array<string>} [toolTypes] 
         * @param {boolean} [active] 
         * @param {Array<string>} [setupRanges] 
         * @param {Array<string>} [removedRanges] 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {Ordering} [ordering] 
         * @param {FishingFacilitiesSorting} [sorting] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fishingFacilities: async (mmsis?: Array<number>, fiskeridirVesselIds?: Array<number>, toolTypes?: Array<string>, active?: boolean, setupRanges?: Array<string>, removedRanges?: Array<string>, limit?: number, offset?: number, ordering?: Ordering, sorting?: FishingFacilitiesSorting, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1.0/fishing_facilities`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication auth0 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "auth0", [], configuration)

            if (mmsis) {
                localVarQueryParameter['mmsis[]'] = mmsis;
            }

            if (fiskeridirVesselIds) {
                localVarQueryParameter['fiskeridirVesselIds[]'] = fiskeridirVesselIds;
            }

            if (toolTypes) {
                localVarQueryParameter['toolTypes[]'] = toolTypes;
            }

            if (active !== undefined) {
                localVarQueryParameter['active'] = active;
            }

            if (setupRanges) {
                localVarQueryParameter['setupRanges[]'] = setupRanges;
            }

            if (removedRanges) {
                localVarQueryParameter['removedRanges[]'] = removedRanges;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * V1fishingFacilityApi - functional programming interface
 * @export
 */
export const V1fishingFacilityApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = V1fishingFacilityApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {Array<number>} [mmsis] 
         * @param {Array<number>} [fiskeridirVesselIds] 
         * @param {Array<string>} [toolTypes] 
         * @param {boolean} [active] 
         * @param {Array<string>} [setupRanges] 
         * @param {Array<string>} [removedRanges] 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {Ordering} [ordering] 
         * @param {FishingFacilitiesSorting} [sorting] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fishingFacilities(mmsis?: Array<number>, fiskeridirVesselIds?: Array<number>, toolTypes?: Array<string>, active?: boolean, setupRanges?: Array<string>, removedRanges?: Array<string>, limit?: number, offset?: number, ordering?: Ordering, sorting?: FishingFacilitiesSorting, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FishingFacility>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fishingFacilities(mmsis, fiskeridirVesselIds, toolTypes, active, setupRanges, removedRanges, limit, offset, ordering, sorting, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * V1fishingFacilityApi - factory interface
 * @export
 */
export const V1fishingFacilityApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = V1fishingFacilityApiFp(configuration)
    return {
        /**
         * 
         * @param {V1fishingFacilityApiFishingFacilitiesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fishingFacilities(requestParameters: V1fishingFacilityApiFishingFacilitiesRequest = {}, options?: AxiosRequestConfig): AxiosPromise<Array<FishingFacility>> {
            return localVarFp.fishingFacilities(requestParameters.mmsis, requestParameters.fiskeridirVesselIds, requestParameters.toolTypes, requestParameters.active, requestParameters.setupRanges, requestParameters.removedRanges, requestParameters.limit, requestParameters.offset, requestParameters.ordering, requestParameters.sorting, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for fishingFacilities operation in V1fishingFacilityApi.
 * @export
 * @interface V1fishingFacilityApiFishingFacilitiesRequest
 */
export interface V1fishingFacilityApiFishingFacilitiesRequest {
    /**
     * 
     * @type {Array<number>}
     * @memberof V1fishingFacilityApiFishingFacilities
     */
    readonly mmsis?: Array<number>

    /**
     * 
     * @type {Array<number>}
     * @memberof V1fishingFacilityApiFishingFacilities
     */
    readonly fiskeridirVesselIds?: Array<number>

    /**
     * 
     * @type {Array<string>}
     * @memberof V1fishingFacilityApiFishingFacilities
     */
    readonly toolTypes?: Array<string>

    /**
     * 
     * @type {boolean}
     * @memberof V1fishingFacilityApiFishingFacilities
     */
    readonly active?: boolean

    /**
     * 
     * @type {Array<string>}
     * @memberof V1fishingFacilityApiFishingFacilities
     */
    readonly setupRanges?: Array<string>

    /**
     * 
     * @type {Array<string>}
     * @memberof V1fishingFacilityApiFishingFacilities
     */
    readonly removedRanges?: Array<string>

    /**
     * 
     * @type {number}
     * @memberof V1fishingFacilityApiFishingFacilities
     */
    readonly limit?: number

    /**
     * 
     * @type {number}
     * @memberof V1fishingFacilityApiFishingFacilities
     */
    readonly offset?: number

    /**
     * 
     * @type {Ordering}
     * @memberof V1fishingFacilityApiFishingFacilities
     */
    readonly ordering?: Ordering

    /**
     * 
     * @type {FishingFacilitiesSorting}
     * @memberof V1fishingFacilityApiFishingFacilities
     */
    readonly sorting?: FishingFacilitiesSorting
}

/**
 * V1fishingFacilityApi - object-oriented interface
 * @export
 * @class V1fishingFacilityApi
 * @extends {BaseAPI}
 */
export class V1fishingFacilityApi extends BaseAPI {
    /**
     * 
     * @param {V1fishingFacilityApiFishingFacilitiesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1fishingFacilityApi
     */
    public fishingFacilities(requestParameters: V1fishingFacilityApiFishingFacilitiesRequest = {}, options?: AxiosRequestConfig) {
        return V1fishingFacilityApiFp(this.configuration).fishingFacilities(requestParameters.mmsis, requestParameters.fiskeridirVesselIds, requestParameters.toolTypes, requestParameters.active, requestParameters.setupRanges, requestParameters.removedRanges, requestParameters.limit, requestParameters.offset, requestParameters.ordering, requestParameters.sorting, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * V1fishingPredictionApi - axios parameter creator
 * @export
 */
export const V1fishingPredictionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ModelId} modelId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allFishingSpotPredictions: async (modelId: ModelId, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'modelId' is not null or undefined
            assertParamExists('allFishingSpotPredictions', 'modelId', modelId)
            const localVarPath = `/v1.0/fishing_spot_predictions/{model_id}`
                .replace(`{${"model_id"}}`, encodeURIComponent(String(modelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication auth0 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "auth0", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ModelId} modelId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allFishingWeightPredictions: async (modelId: ModelId, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'modelId' is not null or undefined
            assertParamExists('allFishingWeightPredictions', 'modelId', modelId)
            const localVarPath = `/v1.0/fishing_weight_predictions/{model_id}`
                .replace(`{${"model_id"}}`, encodeURIComponent(String(modelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication auth0 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "auth0", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ModelId} modelId 
         * @param {SpeciesGroup} speciesGroupId 
         * @param {string} [date] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fishingSpotPredictions: async (modelId: ModelId, speciesGroupId: SpeciesGroup, date?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'modelId' is not null or undefined
            assertParamExists('fishingSpotPredictions', 'modelId', modelId)
            // verify required parameter 'speciesGroupId' is not null or undefined
            assertParamExists('fishingSpotPredictions', 'speciesGroupId', speciesGroupId)
            const localVarPath = `/v1.0/fishing_spot_predictions/{model_id}/{species_group_id}`
                .replace(`{${"model_id"}}`, encodeURIComponent(String(modelId)))
                .replace(`{${"species_group_id"}}`, encodeURIComponent(String(speciesGroupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication auth0 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "auth0", [], configuration)

            if (date !== undefined) {
                localVarQueryParameter['date'] = (date as any instanceof Date) ?
                    (date as any).toISOString().substr(0,10) :
                    date;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ModelId} modelId 
         * @param {SpeciesGroup} speciesGroupId 
         * @param {string} [date] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fishingWeightPredictions: async (modelId: ModelId, speciesGroupId: SpeciesGroup, date?: string, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'modelId' is not null or undefined
            assertParamExists('fishingWeightPredictions', 'modelId', modelId)
            // verify required parameter 'speciesGroupId' is not null or undefined
            assertParamExists('fishingWeightPredictions', 'speciesGroupId', speciesGroupId)
            const localVarPath = `/v1.0/fishing_weight_predictions/{model_id}/{species_group_id}`
                .replace(`{${"model_id"}}`, encodeURIComponent(String(modelId)))
                .replace(`{${"species_group_id"}}`, encodeURIComponent(String(speciesGroupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication auth0 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "auth0", [], configuration)

            if (date !== undefined) {
                localVarQueryParameter['date'] = (date as any instanceof Date) ?
                    (date as any).toISOString().substr(0,10) :
                    date;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * V1fishingPredictionApi - functional programming interface
 * @export
 */
export const V1fishingPredictionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = V1fishingPredictionApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {ModelId} modelId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async allFishingSpotPredictions(modelId: ModelId, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FishingSpotPrediction>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.allFishingSpotPredictions(modelId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {ModelId} modelId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async allFishingWeightPredictions(modelId: ModelId, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FishingWeightPrediction>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.allFishingWeightPredictions(modelId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {ModelId} modelId 
         * @param {SpeciesGroup} speciesGroupId 
         * @param {string} [date] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fishingSpotPredictions(modelId: ModelId, speciesGroupId: SpeciesGroup, date?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FishingSpotPrediction>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fishingSpotPredictions(modelId, speciesGroupId, date, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {ModelId} modelId 
         * @param {SpeciesGroup} speciesGroupId 
         * @param {string} [date] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fishingWeightPredictions(modelId: ModelId, speciesGroupId: SpeciesGroup, date?: string, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FishingWeightPrediction>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fishingWeightPredictions(modelId, speciesGroupId, date, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * V1fishingPredictionApi - factory interface
 * @export
 */
export const V1fishingPredictionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = V1fishingPredictionApiFp(configuration)
    return {
        /**
         * 
         * @param {V1fishingPredictionApiAllFishingSpotPredictionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allFishingSpotPredictions(requestParameters: V1fishingPredictionApiAllFishingSpotPredictionsRequest, options?: AxiosRequestConfig): AxiosPromise<Array<FishingSpotPrediction>> {
            return localVarFp.allFishingSpotPredictions(requestParameters.modelId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {V1fishingPredictionApiAllFishingWeightPredictionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allFishingWeightPredictions(requestParameters: V1fishingPredictionApiAllFishingWeightPredictionsRequest, options?: AxiosRequestConfig): AxiosPromise<Array<FishingWeightPrediction>> {
            return localVarFp.allFishingWeightPredictions(requestParameters.modelId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {V1fishingPredictionApiFishingSpotPredictionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fishingSpotPredictions(requestParameters: V1fishingPredictionApiFishingSpotPredictionsRequest, options?: AxiosRequestConfig): AxiosPromise<FishingSpotPrediction> {
            return localVarFp.fishingSpotPredictions(requestParameters.modelId, requestParameters.speciesGroupId, requestParameters.date, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {V1fishingPredictionApiFishingWeightPredictionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fishingWeightPredictions(requestParameters: V1fishingPredictionApiFishingWeightPredictionsRequest, options?: AxiosRequestConfig): AxiosPromise<Array<FishingWeightPrediction>> {
            return localVarFp.fishingWeightPredictions(requestParameters.modelId, requestParameters.speciesGroupId, requestParameters.date, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for allFishingSpotPredictions operation in V1fishingPredictionApi.
 * @export
 * @interface V1fishingPredictionApiAllFishingSpotPredictionsRequest
 */
export interface V1fishingPredictionApiAllFishingSpotPredictionsRequest {
    /**
     * 
     * @type {ModelId}
     * @memberof V1fishingPredictionApiAllFishingSpotPredictions
     */
    readonly modelId: ModelId
}

/**
 * Request parameters for allFishingWeightPredictions operation in V1fishingPredictionApi.
 * @export
 * @interface V1fishingPredictionApiAllFishingWeightPredictionsRequest
 */
export interface V1fishingPredictionApiAllFishingWeightPredictionsRequest {
    /**
     * 
     * @type {ModelId}
     * @memberof V1fishingPredictionApiAllFishingWeightPredictions
     */
    readonly modelId: ModelId
}

/**
 * Request parameters for fishingSpotPredictions operation in V1fishingPredictionApi.
 * @export
 * @interface V1fishingPredictionApiFishingSpotPredictionsRequest
 */
export interface V1fishingPredictionApiFishingSpotPredictionsRequest {
    /**
     * 
     * @type {ModelId}
     * @memberof V1fishingPredictionApiFishingSpotPredictions
     */
    readonly modelId: ModelId

    /**
     * 
     * @type {SpeciesGroup}
     * @memberof V1fishingPredictionApiFishingSpotPredictions
     */
    readonly speciesGroupId: SpeciesGroup

    /**
     * 
     * @type {string}
     * @memberof V1fishingPredictionApiFishingSpotPredictions
     */
    readonly date?: string
}

/**
 * Request parameters for fishingWeightPredictions operation in V1fishingPredictionApi.
 * @export
 * @interface V1fishingPredictionApiFishingWeightPredictionsRequest
 */
export interface V1fishingPredictionApiFishingWeightPredictionsRequest {
    /**
     * 
     * @type {ModelId}
     * @memberof V1fishingPredictionApiFishingWeightPredictions
     */
    readonly modelId: ModelId

    /**
     * 
     * @type {SpeciesGroup}
     * @memberof V1fishingPredictionApiFishingWeightPredictions
     */
    readonly speciesGroupId: SpeciesGroup

    /**
     * 
     * @type {string}
     * @memberof V1fishingPredictionApiFishingWeightPredictions
     */
    readonly date?: string

    /**
     * 
     * @type {number}
     * @memberof V1fishingPredictionApiFishingWeightPredictions
     */
    readonly limit?: number
}

/**
 * V1fishingPredictionApi - object-oriented interface
 * @export
 * @class V1fishingPredictionApi
 * @extends {BaseAPI}
 */
export class V1fishingPredictionApi extends BaseAPI {
    /**
     * 
     * @param {V1fishingPredictionApiAllFishingSpotPredictionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1fishingPredictionApi
     */
    public allFishingSpotPredictions(requestParameters: V1fishingPredictionApiAllFishingSpotPredictionsRequest, options?: AxiosRequestConfig) {
        return V1fishingPredictionApiFp(this.configuration).allFishingSpotPredictions(requestParameters.modelId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {V1fishingPredictionApiAllFishingWeightPredictionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1fishingPredictionApi
     */
    public allFishingWeightPredictions(requestParameters: V1fishingPredictionApiAllFishingWeightPredictionsRequest, options?: AxiosRequestConfig) {
        return V1fishingPredictionApiFp(this.configuration).allFishingWeightPredictions(requestParameters.modelId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {V1fishingPredictionApiFishingSpotPredictionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1fishingPredictionApi
     */
    public fishingSpotPredictions(requestParameters: V1fishingPredictionApiFishingSpotPredictionsRequest, options?: AxiosRequestConfig) {
        return V1fishingPredictionApiFp(this.configuration).fishingSpotPredictions(requestParameters.modelId, requestParameters.speciesGroupId, requestParameters.date, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {V1fishingPredictionApiFishingWeightPredictionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1fishingPredictionApi
     */
    public fishingWeightPredictions(requestParameters: V1fishingPredictionApiFishingWeightPredictionsRequest, options?: AxiosRequestConfig) {
        return V1fishingPredictionApiFp(this.configuration).fishingWeightPredictions(requestParameters.modelId, requestParameters.speciesGroupId, requestParameters.date, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * V1gearApi - axios parameter creator
 * @export
 */
export const V1gearApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gear: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1.0/gear`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication auth0 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "auth0", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gearGroups: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1.0/gear_groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication auth0 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "auth0", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gearMainGroups: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1.0/gear_main_groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication auth0 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "auth0", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * V1gearApi - functional programming interface
 * @export
 */
export const V1gearApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = V1gearApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gear(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GearDetailed>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gear(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gearGroups(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GearGroupDetailed>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gearGroups(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gearMainGroups(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GearMainGroupDetailed>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gearMainGroups(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * V1gearApi - factory interface
 * @export
 */
export const V1gearApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = V1gearApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gear(options?: AxiosRequestConfig): AxiosPromise<Array<GearDetailed>> {
            return localVarFp.gear(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gearGroups(options?: AxiosRequestConfig): AxiosPromise<Array<GearGroupDetailed>> {
            return localVarFp.gearGroups(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gearMainGroups(options?: AxiosRequestConfig): AxiosPromise<Array<GearMainGroupDetailed>> {
            return localVarFp.gearMainGroups(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * V1gearApi - object-oriented interface
 * @export
 * @class V1gearApi
 * @extends {BaseAPI}
 */
export class V1gearApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1gearApi
     */
    public gear(options?: AxiosRequestConfig) {
        return V1gearApiFp(this.configuration).gear(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1gearApi
     */
    public gearGroups(options?: AxiosRequestConfig) {
        return V1gearApiFp(this.configuration).gearGroups(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1gearApi
     */
    public gearMainGroups(options?: AxiosRequestConfig) {
        return V1gearApiFp(this.configuration).gearMainGroups(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * V1haulApi - axios parameter creator
 * @export
 */
export const V1haulApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Array<string>} [months] 
         * @param {Array<string>} [catchLocations] 
         * @param {Array<string>} [gearGroupIds] 
         * @param {Array<string>} [speciesGroupIds] 
         * @param {Array<string>} [vesselLengthGroups] 
         * @param {Array<number>} [fiskeridirVesselIds] 
         * @param {number} [minWindSpeed] 
         * @param {number} [maxWindSpeed] 
         * @param {number} [minAirTemperature] 
         * @param {number} [maxAirTemperature] 
         * @param {HaulsSorting} [sorting] 
         * @param {Ordering} [ordering] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hauls: async (months?: Array<string>, catchLocations?: Array<string>, gearGroupIds?: Array<string>, speciesGroupIds?: Array<string>, vesselLengthGroups?: Array<string>, fiskeridirVesselIds?: Array<number>, minWindSpeed?: number, maxWindSpeed?: number, minAirTemperature?: number, maxAirTemperature?: number, sorting?: HaulsSorting, ordering?: Ordering, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1.0/hauls`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication auth0 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "auth0", [], configuration)

            if (months) {
                localVarQueryParameter['months[]'] = months;
            }

            if (catchLocations) {
                localVarQueryParameter['catchLocations[]'] = catchLocations;
            }

            if (gearGroupIds) {
                localVarQueryParameter['gearGroupIds[]'] = gearGroupIds;
            }

            if (speciesGroupIds) {
                localVarQueryParameter['speciesGroupIds[]'] = speciesGroupIds;
            }

            if (vesselLengthGroups) {
                localVarQueryParameter['vesselLengthGroups[]'] = vesselLengthGroups;
            }

            if (fiskeridirVesselIds) {
                localVarQueryParameter['fiskeridirVesselIds[]'] = fiskeridirVesselIds;
            }

            if (minWindSpeed !== undefined) {
                localVarQueryParameter['minWindSpeed'] = minWindSpeed;
            }

            if (maxWindSpeed !== undefined) {
                localVarQueryParameter['maxWindSpeed'] = maxWindSpeed;
            }

            if (minAirTemperature !== undefined) {
                localVarQueryParameter['minAirTemperature'] = minAirTemperature;
            }

            if (maxAirTemperature !== undefined) {
                localVarQueryParameter['maxAirTemperature'] = maxAirTemperature;
            }

            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ActiveHaulsFilter} activeFilter 
         * @param {Array<number>} [months] 
         * @param {Array<string>} [catchLocations] 
         * @param {Array<string>} [gearGroupIds] 
         * @param {Array<string>} [speciesGroupIds] 
         * @param {Array<string>} [vesselLengthGroups] 
         * @param {Array<number>} [fiskeridirVesselIds] 
         * @param {number} [bycatchPercentage] 
         * @param {boolean} [majoritySpeciesGroup] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        haulsMatrix: async (activeFilter: ActiveHaulsFilter, months?: Array<number>, catchLocations?: Array<string>, gearGroupIds?: Array<string>, speciesGroupIds?: Array<string>, vesselLengthGroups?: Array<string>, fiskeridirVesselIds?: Array<number>, bycatchPercentage?: number, majoritySpeciesGroup?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'activeFilter' is not null or undefined
            assertParamExists('haulsMatrix', 'activeFilter', activeFilter)
            const localVarPath = `/v1.0/hauls_matrix/{active_filter}`
                .replace(`{${"active_filter"}}`, encodeURIComponent(String(activeFilter)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication auth0 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "auth0", [], configuration)

            if (months) {
                localVarQueryParameter['months[]'] = months;
            }

            if (catchLocations) {
                localVarQueryParameter['catchLocations[]'] = catchLocations;
            }

            if (gearGroupIds) {
                localVarQueryParameter['gearGroupIds[]'] = gearGroupIds;
            }

            if (speciesGroupIds) {
                localVarQueryParameter['speciesGroupIds[]'] = speciesGroupIds;
            }

            if (vesselLengthGroups) {
                localVarQueryParameter['vesselLengthGroups[]'] = vesselLengthGroups;
            }

            if (fiskeridirVesselIds) {
                localVarQueryParameter['fiskeridirVesselIds[]'] = fiskeridirVesselIds;
            }

            if (bycatchPercentage !== undefined) {
                localVarQueryParameter['bycatchPercentage'] = bycatchPercentage;
            }

            if (majoritySpeciesGroup !== undefined) {
                localVarQueryParameter['majoritySpeciesGroup'] = majoritySpeciesGroup;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * V1haulApi - functional programming interface
 * @export
 */
export const V1haulApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = V1haulApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {Array<string>} [months] 
         * @param {Array<string>} [catchLocations] 
         * @param {Array<string>} [gearGroupIds] 
         * @param {Array<string>} [speciesGroupIds] 
         * @param {Array<string>} [vesselLengthGroups] 
         * @param {Array<number>} [fiskeridirVesselIds] 
         * @param {number} [minWindSpeed] 
         * @param {number} [maxWindSpeed] 
         * @param {number} [minAirTemperature] 
         * @param {number} [maxAirTemperature] 
         * @param {HaulsSorting} [sorting] 
         * @param {Ordering} [ordering] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async hauls(months?: Array<string>, catchLocations?: Array<string>, gearGroupIds?: Array<string>, speciesGroupIds?: Array<string>, vesselLengthGroups?: Array<string>, fiskeridirVesselIds?: Array<number>, minWindSpeed?: number, maxWindSpeed?: number, minAirTemperature?: number, maxAirTemperature?: number, sorting?: HaulsSorting, ordering?: Ordering, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Haul>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.hauls(months, catchLocations, gearGroupIds, speciesGroupIds, vesselLengthGroups, fiskeridirVesselIds, minWindSpeed, maxWindSpeed, minAirTemperature, maxAirTemperature, sorting, ordering, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {ActiveHaulsFilter} activeFilter 
         * @param {Array<number>} [months] 
         * @param {Array<string>} [catchLocations] 
         * @param {Array<string>} [gearGroupIds] 
         * @param {Array<string>} [speciesGroupIds] 
         * @param {Array<string>} [vesselLengthGroups] 
         * @param {Array<number>} [fiskeridirVesselIds] 
         * @param {number} [bycatchPercentage] 
         * @param {boolean} [majoritySpeciesGroup] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async haulsMatrix(activeFilter: ActiveHaulsFilter, months?: Array<number>, catchLocations?: Array<string>, gearGroupIds?: Array<string>, speciesGroupIds?: Array<string>, vesselLengthGroups?: Array<string>, fiskeridirVesselIds?: Array<number>, bycatchPercentage?: number, majoritySpeciesGroup?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HaulsMatrix>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.haulsMatrix(activeFilter, months, catchLocations, gearGroupIds, speciesGroupIds, vesselLengthGroups, fiskeridirVesselIds, bycatchPercentage, majoritySpeciesGroup, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * V1haulApi - factory interface
 * @export
 */
export const V1haulApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = V1haulApiFp(configuration)
    return {
        /**
         * 
         * @param {V1haulApiHaulsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hauls(requestParameters: V1haulApiHaulsRequest = {}, options?: AxiosRequestConfig): AxiosPromise<Array<Haul>> {
            return localVarFp.hauls(requestParameters.months, requestParameters.catchLocations, requestParameters.gearGroupIds, requestParameters.speciesGroupIds, requestParameters.vesselLengthGroups, requestParameters.fiskeridirVesselIds, requestParameters.minWindSpeed, requestParameters.maxWindSpeed, requestParameters.minAirTemperature, requestParameters.maxAirTemperature, requestParameters.sorting, requestParameters.ordering, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {V1haulApiHaulsMatrixRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        haulsMatrix(requestParameters: V1haulApiHaulsMatrixRequest, options?: AxiosRequestConfig): AxiosPromise<HaulsMatrix> {
            return localVarFp.haulsMatrix(requestParameters.activeFilter, requestParameters.months, requestParameters.catchLocations, requestParameters.gearGroupIds, requestParameters.speciesGroupIds, requestParameters.vesselLengthGroups, requestParameters.fiskeridirVesselIds, requestParameters.bycatchPercentage, requestParameters.majoritySpeciesGroup, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for hauls operation in V1haulApi.
 * @export
 * @interface V1haulApiHaulsRequest
 */
export interface V1haulApiHaulsRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof V1haulApiHauls
     */
    readonly months?: Array<string>

    /**
     * 
     * @type {Array<string>}
     * @memberof V1haulApiHauls
     */
    readonly catchLocations?: Array<string>

    /**
     * 
     * @type {Array<string>}
     * @memberof V1haulApiHauls
     */
    readonly gearGroupIds?: Array<string>

    /**
     * 
     * @type {Array<string>}
     * @memberof V1haulApiHauls
     */
    readonly speciesGroupIds?: Array<string>

    /**
     * 
     * @type {Array<string>}
     * @memberof V1haulApiHauls
     */
    readonly vesselLengthGroups?: Array<string>

    /**
     * 
     * @type {Array<number>}
     * @memberof V1haulApiHauls
     */
    readonly fiskeridirVesselIds?: Array<number>

    /**
     * 
     * @type {number}
     * @memberof V1haulApiHauls
     */
    readonly minWindSpeed?: number

    /**
     * 
     * @type {number}
     * @memberof V1haulApiHauls
     */
    readonly maxWindSpeed?: number

    /**
     * 
     * @type {number}
     * @memberof V1haulApiHauls
     */
    readonly minAirTemperature?: number

    /**
     * 
     * @type {number}
     * @memberof V1haulApiHauls
     */
    readonly maxAirTemperature?: number

    /**
     * 
     * @type {HaulsSorting}
     * @memberof V1haulApiHauls
     */
    readonly sorting?: HaulsSorting

    /**
     * 
     * @type {Ordering}
     * @memberof V1haulApiHauls
     */
    readonly ordering?: Ordering
}

/**
 * Request parameters for haulsMatrix operation in V1haulApi.
 * @export
 * @interface V1haulApiHaulsMatrixRequest
 */
export interface V1haulApiHaulsMatrixRequest {
    /**
     * 
     * @type {ActiveHaulsFilter}
     * @memberof V1haulApiHaulsMatrix
     */
    readonly activeFilter: ActiveHaulsFilter

    /**
     * 
     * @type {Array<number>}
     * @memberof V1haulApiHaulsMatrix
     */
    readonly months?: Array<number>

    /**
     * 
     * @type {Array<string>}
     * @memberof V1haulApiHaulsMatrix
     */
    readonly catchLocations?: Array<string>

    /**
     * 
     * @type {Array<string>}
     * @memberof V1haulApiHaulsMatrix
     */
    readonly gearGroupIds?: Array<string>

    /**
     * 
     * @type {Array<string>}
     * @memberof V1haulApiHaulsMatrix
     */
    readonly speciesGroupIds?: Array<string>

    /**
     * 
     * @type {Array<string>}
     * @memberof V1haulApiHaulsMatrix
     */
    readonly vesselLengthGroups?: Array<string>

    /**
     * 
     * @type {Array<number>}
     * @memberof V1haulApiHaulsMatrix
     */
    readonly fiskeridirVesselIds?: Array<number>

    /**
     * 
     * @type {number}
     * @memberof V1haulApiHaulsMatrix
     */
    readonly bycatchPercentage?: number

    /**
     * 
     * @type {boolean}
     * @memberof V1haulApiHaulsMatrix
     */
    readonly majoritySpeciesGroup?: boolean
}

/**
 * V1haulApi - object-oriented interface
 * @export
 * @class V1haulApi
 * @extends {BaseAPI}
 */
export class V1haulApi extends BaseAPI {
    /**
     * 
     * @param {V1haulApiHaulsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1haulApi
     */
    public hauls(requestParameters: V1haulApiHaulsRequest = {}, options?: AxiosRequestConfig) {
        return V1haulApiFp(this.configuration).hauls(requestParameters.months, requestParameters.catchLocations, requestParameters.gearGroupIds, requestParameters.speciesGroupIds, requestParameters.vesselLengthGroups, requestParameters.fiskeridirVesselIds, requestParameters.minWindSpeed, requestParameters.maxWindSpeed, requestParameters.minAirTemperature, requestParameters.maxAirTemperature, requestParameters.sorting, requestParameters.ordering, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {V1haulApiHaulsMatrixRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1haulApi
     */
    public haulsMatrix(requestParameters: V1haulApiHaulsMatrixRequest, options?: AxiosRequestConfig) {
        return V1haulApiFp(this.configuration).haulsMatrix(requestParameters.activeFilter, requestParameters.months, requestParameters.catchLocations, requestParameters.gearGroupIds, requestParameters.speciesGroupIds, requestParameters.vesselLengthGroups, requestParameters.fiskeridirVesselIds, requestParameters.bycatchPercentage, requestParameters.majoritySpeciesGroup, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * V1landingApi - axios parameter creator
 * @export
 */
export const V1landingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ActiveLandingFilter} activeFilter 
         * @param {Array<number>} [months] 
         * @param {Array<string>} [catchLocations] 
         * @param {Array<string>} [gearGroupIds] 
         * @param {Array<string>} [speciesGroupIds] 
         * @param {Array<string>} [vesselLengthGroups] 
         * @param {Array<number>} [fiskeridirVesselIds] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        landingMatrix: async (activeFilter: ActiveLandingFilter, months?: Array<number>, catchLocations?: Array<string>, gearGroupIds?: Array<string>, speciesGroupIds?: Array<string>, vesselLengthGroups?: Array<string>, fiskeridirVesselIds?: Array<number>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'activeFilter' is not null or undefined
            assertParamExists('landingMatrix', 'activeFilter', activeFilter)
            const localVarPath = `/v1.0/landing_matrix/{active_filter}`
                .replace(`{${"active_filter"}}`, encodeURIComponent(String(activeFilter)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication auth0 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "auth0", [], configuration)

            if (months) {
                localVarQueryParameter['months[]'] = months;
            }

            if (catchLocations) {
                localVarQueryParameter['catchLocations[]'] = catchLocations;
            }

            if (gearGroupIds) {
                localVarQueryParameter['gearGroupIds[]'] = gearGroupIds;
            }

            if (speciesGroupIds) {
                localVarQueryParameter['speciesGroupIds[]'] = speciesGroupIds;
            }

            if (vesselLengthGroups) {
                localVarQueryParameter['vesselLengthGroups[]'] = vesselLengthGroups;
            }

            if (fiskeridirVesselIds) {
                localVarQueryParameter['fiskeridirVesselIds[]'] = fiskeridirVesselIds;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Array<string>} [months] 
         * @param {Array<string>} [catchLocations] 
         * @param {Array<string>} [gearGroupIds] 
         * @param {Array<string>} [speciesGroupIds] 
         * @param {Array<string>} [vesselLengthGroups] 
         * @param {Array<number>} [fiskeridirVesselIds] 
         * @param {LandingsSorting} [sorting] 
         * @param {Ordering} [ordering] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        landings: async (months?: Array<string>, catchLocations?: Array<string>, gearGroupIds?: Array<string>, speciesGroupIds?: Array<string>, vesselLengthGroups?: Array<string>, fiskeridirVesselIds?: Array<number>, sorting?: LandingsSorting, ordering?: Ordering, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1.0/landings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication auth0 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "auth0", [], configuration)

            if (months) {
                localVarQueryParameter['months[]'] = months;
            }

            if (catchLocations) {
                localVarQueryParameter['catchLocations[]'] = catchLocations;
            }

            if (gearGroupIds) {
                localVarQueryParameter['gearGroupIds[]'] = gearGroupIds;
            }

            if (speciesGroupIds) {
                localVarQueryParameter['speciesGroupIds[]'] = speciesGroupIds;
            }

            if (vesselLengthGroups) {
                localVarQueryParameter['vesselLengthGroups[]'] = vesselLengthGroups;
            }

            if (fiskeridirVesselIds) {
                localVarQueryParameter['fiskeridirVesselIds[]'] = fiskeridirVesselIds;
            }

            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * V1landingApi - functional programming interface
 * @export
 */
export const V1landingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = V1landingApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {ActiveLandingFilter} activeFilter 
         * @param {Array<number>} [months] 
         * @param {Array<string>} [catchLocations] 
         * @param {Array<string>} [gearGroupIds] 
         * @param {Array<string>} [speciesGroupIds] 
         * @param {Array<string>} [vesselLengthGroups] 
         * @param {Array<number>} [fiskeridirVesselIds] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async landingMatrix(activeFilter: ActiveLandingFilter, months?: Array<number>, catchLocations?: Array<string>, gearGroupIds?: Array<string>, speciesGroupIds?: Array<string>, vesselLengthGroups?: Array<string>, fiskeridirVesselIds?: Array<number>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LandingMatrix>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.landingMatrix(activeFilter, months, catchLocations, gearGroupIds, speciesGroupIds, vesselLengthGroups, fiskeridirVesselIds, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Array<string>} [months] 
         * @param {Array<string>} [catchLocations] 
         * @param {Array<string>} [gearGroupIds] 
         * @param {Array<string>} [speciesGroupIds] 
         * @param {Array<string>} [vesselLengthGroups] 
         * @param {Array<number>} [fiskeridirVesselIds] 
         * @param {LandingsSorting} [sorting] 
         * @param {Ordering} [ordering] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async landings(months?: Array<string>, catchLocations?: Array<string>, gearGroupIds?: Array<string>, speciesGroupIds?: Array<string>, vesselLengthGroups?: Array<string>, fiskeridirVesselIds?: Array<number>, sorting?: LandingsSorting, ordering?: Ordering, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Landing>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.landings(months, catchLocations, gearGroupIds, speciesGroupIds, vesselLengthGroups, fiskeridirVesselIds, sorting, ordering, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * V1landingApi - factory interface
 * @export
 */
export const V1landingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = V1landingApiFp(configuration)
    return {
        /**
         * 
         * @param {V1landingApiLandingMatrixRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        landingMatrix(requestParameters: V1landingApiLandingMatrixRequest, options?: AxiosRequestConfig): AxiosPromise<LandingMatrix> {
            return localVarFp.landingMatrix(requestParameters.activeFilter, requestParameters.months, requestParameters.catchLocations, requestParameters.gearGroupIds, requestParameters.speciesGroupIds, requestParameters.vesselLengthGroups, requestParameters.fiskeridirVesselIds, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {V1landingApiLandingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        landings(requestParameters: V1landingApiLandingsRequest = {}, options?: AxiosRequestConfig): AxiosPromise<Array<Landing>> {
            return localVarFp.landings(requestParameters.months, requestParameters.catchLocations, requestParameters.gearGroupIds, requestParameters.speciesGroupIds, requestParameters.vesselLengthGroups, requestParameters.fiskeridirVesselIds, requestParameters.sorting, requestParameters.ordering, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for landingMatrix operation in V1landingApi.
 * @export
 * @interface V1landingApiLandingMatrixRequest
 */
export interface V1landingApiLandingMatrixRequest {
    /**
     * 
     * @type {ActiveLandingFilter}
     * @memberof V1landingApiLandingMatrix
     */
    readonly activeFilter: ActiveLandingFilter

    /**
     * 
     * @type {Array<number>}
     * @memberof V1landingApiLandingMatrix
     */
    readonly months?: Array<number>

    /**
     * 
     * @type {Array<string>}
     * @memberof V1landingApiLandingMatrix
     */
    readonly catchLocations?: Array<string>

    /**
     * 
     * @type {Array<string>}
     * @memberof V1landingApiLandingMatrix
     */
    readonly gearGroupIds?: Array<string>

    /**
     * 
     * @type {Array<string>}
     * @memberof V1landingApiLandingMatrix
     */
    readonly speciesGroupIds?: Array<string>

    /**
     * 
     * @type {Array<string>}
     * @memberof V1landingApiLandingMatrix
     */
    readonly vesselLengthGroups?: Array<string>

    /**
     * 
     * @type {Array<number>}
     * @memberof V1landingApiLandingMatrix
     */
    readonly fiskeridirVesselIds?: Array<number>
}

/**
 * Request parameters for landings operation in V1landingApi.
 * @export
 * @interface V1landingApiLandingsRequest
 */
export interface V1landingApiLandingsRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof V1landingApiLandings
     */
    readonly months?: Array<string>

    /**
     * 
     * @type {Array<string>}
     * @memberof V1landingApiLandings
     */
    readonly catchLocations?: Array<string>

    /**
     * 
     * @type {Array<string>}
     * @memberof V1landingApiLandings
     */
    readonly gearGroupIds?: Array<string>

    /**
     * 
     * @type {Array<string>}
     * @memberof V1landingApiLandings
     */
    readonly speciesGroupIds?: Array<string>

    /**
     * 
     * @type {Array<string>}
     * @memberof V1landingApiLandings
     */
    readonly vesselLengthGroups?: Array<string>

    /**
     * 
     * @type {Array<number>}
     * @memberof V1landingApiLandings
     */
    readonly fiskeridirVesselIds?: Array<number>

    /**
     * 
     * @type {LandingsSorting}
     * @memberof V1landingApiLandings
     */
    readonly sorting?: LandingsSorting

    /**
     * 
     * @type {Ordering}
     * @memberof V1landingApiLandings
     */
    readonly ordering?: Ordering
}

/**
 * V1landingApi - object-oriented interface
 * @export
 * @class V1landingApi
 * @extends {BaseAPI}
 */
export class V1landingApi extends BaseAPI {
    /**
     * 
     * @param {V1landingApiLandingMatrixRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1landingApi
     */
    public landingMatrix(requestParameters: V1landingApiLandingMatrixRequest, options?: AxiosRequestConfig) {
        return V1landingApiFp(this.configuration).landingMatrix(requestParameters.activeFilter, requestParameters.months, requestParameters.catchLocations, requestParameters.gearGroupIds, requestParameters.speciesGroupIds, requestParameters.vesselLengthGroups, requestParameters.fiskeridirVesselIds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {V1landingApiLandingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1landingApi
     */
    public landings(requestParameters: V1landingApiLandingsRequest = {}, options?: AxiosRequestConfig) {
        return V1landingApiFp(this.configuration).landings(requestParameters.months, requestParameters.catchLocations, requestParameters.gearGroupIds, requestParameters.speciesGroupIds, requestParameters.vesselLengthGroups, requestParameters.fiskeridirVesselIds, requestParameters.sorting, requestParameters.ordering, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * V1speciesApi - axios parameter creator
 * @export
 */
export const V1speciesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        species: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1.0/species`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication auth0 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "auth0", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        speciesFao: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1.0/species_fao`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication auth0 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "auth0", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        speciesFiskeridir: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1.0/species_fiskeridir`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication auth0 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "auth0", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {boolean} [hasMlModels] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        speciesGroups: async (hasMlModels?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1.0/species_groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication auth0 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "auth0", [], configuration)

            if (hasMlModels !== undefined) {
                localVarQueryParameter['hasMlModels'] = hasMlModels;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        speciesMainGroups: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1.0/species_main_groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication auth0 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "auth0", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * V1speciesApi - functional programming interface
 * @export
 */
export const V1speciesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = V1speciesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async species(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Species>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.species(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async speciesFao(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SpeciesFao>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.speciesFao(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async speciesFiskeridir(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SpeciesFiskeridir>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.speciesFiskeridir(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {boolean} [hasMlModels] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async speciesGroups(hasMlModels?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SpeciesGroupDetailed>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.speciesGroups(hasMlModels, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async speciesMainGroups(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SpeciesMainGroupDetailed>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.speciesMainGroups(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * V1speciesApi - factory interface
 * @export
 */
export const V1speciesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = V1speciesApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        species(options?: AxiosRequestConfig): AxiosPromise<Array<Species>> {
            return localVarFp.species(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        speciesFao(options?: AxiosRequestConfig): AxiosPromise<Array<SpeciesFao>> {
            return localVarFp.speciesFao(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        speciesFiskeridir(options?: AxiosRequestConfig): AxiosPromise<Array<SpeciesFiskeridir>> {
            return localVarFp.speciesFiskeridir(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {V1speciesApiSpeciesGroupsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        speciesGroups(requestParameters: V1speciesApiSpeciesGroupsRequest = {}, options?: AxiosRequestConfig): AxiosPromise<Array<SpeciesGroupDetailed>> {
            return localVarFp.speciesGroups(requestParameters.hasMlModels, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        speciesMainGroups(options?: AxiosRequestConfig): AxiosPromise<Array<SpeciesMainGroupDetailed>> {
            return localVarFp.speciesMainGroups(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for speciesGroups operation in V1speciesApi.
 * @export
 * @interface V1speciesApiSpeciesGroupsRequest
 */
export interface V1speciesApiSpeciesGroupsRequest {
    /**
     * 
     * @type {boolean}
     * @memberof V1speciesApiSpeciesGroups
     */
    readonly hasMlModels?: boolean
}

/**
 * V1speciesApi - object-oriented interface
 * @export
 * @class V1speciesApi
 * @extends {BaseAPI}
 */
export class V1speciesApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1speciesApi
     */
    public species(options?: AxiosRequestConfig) {
        return V1speciesApiFp(this.configuration).species(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1speciesApi
     */
    public speciesFao(options?: AxiosRequestConfig) {
        return V1speciesApiFp(this.configuration).speciesFao(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1speciesApi
     */
    public speciesFiskeridir(options?: AxiosRequestConfig) {
        return V1speciesApiFp(this.configuration).speciesFiskeridir(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {V1speciesApiSpeciesGroupsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1speciesApi
     */
    public speciesGroups(requestParameters: V1speciesApiSpeciesGroupsRequest = {}, options?: AxiosRequestConfig) {
        return V1speciesApiFp(this.configuration).speciesGroups(requestParameters.hasMlModels, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1speciesApi
     */
    public speciesMainGroups(options?: AxiosRequestConfig) {
        return V1speciesApiFp(this.configuration).speciesMainGroups(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * V1tripApi - axios parameter creator
 * @export
 */
export const V1tripApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} fiskeridirVesselId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currentTrip: async (fiskeridirVesselId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fiskeridirVesselId' is not null or undefined
            assertParamExists('currentTrip', 'fiskeridirVesselId', fiskeridirVesselId)
            const localVarPath = `/v1.0/trips/current/{fiskeridir_vessel_id}`
                .replace(`{${"fiskeridir_vessel_id"}}`, encodeURIComponent(String(fiskeridirVesselId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication auth0 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "auth0", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} haulId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tripOfHaul: async (haulId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'haulId' is not null or undefined
            assertParamExists('tripOfHaul', 'haulId', haulId)
            const localVarPath = `/v1.0/trip_of_haul/{haul_id}`
                .replace(`{${"haul_id"}}`, encodeURIComponent(String(haulId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication auth0 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "auth0", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} landingId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tripOfLanding: async (landingId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'landingId' is not null or undefined
            assertParamExists('tripOfLanding', 'landingId', landingId)
            const localVarPath = `/v1.0/trip_of_landing/{landing_id}`
                .replace(`{${"landing_id"}}`, encodeURIComponent(String(landingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication auth0 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "auth0", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} landingId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tripOfPartialLanding: async (landingId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'landingId' is not null or undefined
            assertParamExists('tripOfPartialLanding', 'landingId', landingId)
            const localVarPath = `/v1.0/trip_of_partial_landing/{landing_id}`
                .replace(`{${"landing_id"}}`, encodeURIComponent(String(landingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication auth0 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "auth0", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {Ordering} [ordering] 
         * @param {Array<string>} [deliveryPoints] 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {number} [minWeight] 
         * @param {number} [maxWeight] 
         * @param {TripSorting} [sorting] 
         * @param {Array<string>} [gearGroupIds] 
         * @param {Array<string>} [speciesGroupIds] 
         * @param {Array<string>} [vesselLengthGroups] 
         * @param {Array<number>} [fiskeridirVesselIds] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trips: async (limit?: number, offset?: number, ordering?: Ordering, deliveryPoints?: Array<string>, startDate?: string, endDate?: string, minWeight?: number, maxWeight?: number, sorting?: TripSorting, gearGroupIds?: Array<string>, speciesGroupIds?: Array<string>, vesselLengthGroups?: Array<string>, fiskeridirVesselIds?: Array<number>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1.0/trips`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication auth0 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "auth0", [], configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (deliveryPoints) {
                localVarQueryParameter['deliveryPoints[]'] = deliveryPoints;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any instanceof Date) ?
                    (startDate as any).toISOString() :
                    startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any instanceof Date) ?
                    (endDate as any).toISOString() :
                    endDate;
            }

            if (minWeight !== undefined) {
                localVarQueryParameter['minWeight'] = minWeight;
            }

            if (maxWeight !== undefined) {
                localVarQueryParameter['maxWeight'] = maxWeight;
            }

            if (sorting !== undefined) {
                localVarQueryParameter['sorting'] = sorting;
            }

            if (gearGroupIds) {
                localVarQueryParameter['gearGroupIds[]'] = gearGroupIds;
            }

            if (speciesGroupIds) {
                localVarQueryParameter['speciesGroupIds[]'] = speciesGroupIds;
            }

            if (vesselLengthGroups) {
                localVarQueryParameter['vesselLengthGroups[]'] = vesselLengthGroups;
            }

            if (fiskeridirVesselIds) {
                localVarQueryParameter['fiskeridirVesselIds[]'] = fiskeridirVesselIds;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * V1tripApi - functional programming interface
 * @export
 */
export const V1tripApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = V1tripApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} fiskeridirVesselId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async currentTrip(fiskeridirVesselId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CurrentTrip>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.currentTrip(fiskeridirVesselId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} haulId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tripOfHaul(haulId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Trip>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tripOfHaul(haulId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} landingId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tripOfLanding(landingId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Trip>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tripOfLanding(landingId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} landingId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tripOfPartialLanding(landingId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Trip>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tripOfPartialLanding(landingId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {Ordering} [ordering] 
         * @param {Array<string>} [deliveryPoints] 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {number} [minWeight] 
         * @param {number} [maxWeight] 
         * @param {TripSorting} [sorting] 
         * @param {Array<string>} [gearGroupIds] 
         * @param {Array<string>} [speciesGroupIds] 
         * @param {Array<string>} [vesselLengthGroups] 
         * @param {Array<number>} [fiskeridirVesselIds] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trips(limit?: number, offset?: number, ordering?: Ordering, deliveryPoints?: Array<string>, startDate?: string, endDate?: string, minWeight?: number, maxWeight?: number, sorting?: TripSorting, gearGroupIds?: Array<string>, speciesGroupIds?: Array<string>, vesselLengthGroups?: Array<string>, fiskeridirVesselIds?: Array<number>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Trip>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trips(limit, offset, ordering, deliveryPoints, startDate, endDate, minWeight, maxWeight, sorting, gearGroupIds, speciesGroupIds, vesselLengthGroups, fiskeridirVesselIds, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * V1tripApi - factory interface
 * @export
 */
export const V1tripApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = V1tripApiFp(configuration)
    return {
        /**
         * 
         * @param {V1tripApiCurrentTripRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        currentTrip(requestParameters: V1tripApiCurrentTripRequest, options?: AxiosRequestConfig): AxiosPromise<CurrentTrip> {
            return localVarFp.currentTrip(requestParameters.fiskeridirVesselId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {V1tripApiTripOfHaulRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tripOfHaul(requestParameters: V1tripApiTripOfHaulRequest, options?: AxiosRequestConfig): AxiosPromise<Trip> {
            return localVarFp.tripOfHaul(requestParameters.haulId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {V1tripApiTripOfLandingRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tripOfLanding(requestParameters: V1tripApiTripOfLandingRequest, options?: AxiosRequestConfig): AxiosPromise<Trip> {
            return localVarFp.tripOfLanding(requestParameters.landingId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {V1tripApiTripOfPartialLandingRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tripOfPartialLanding(requestParameters: V1tripApiTripOfPartialLandingRequest, options?: AxiosRequestConfig): AxiosPromise<Trip> {
            return localVarFp.tripOfPartialLanding(requestParameters.landingId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {V1tripApiTripsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trips(requestParameters: V1tripApiTripsRequest = {}, options?: AxiosRequestConfig): AxiosPromise<Array<Trip>> {
            return localVarFp.trips(requestParameters.limit, requestParameters.offset, requestParameters.ordering, requestParameters.deliveryPoints, requestParameters.startDate, requestParameters.endDate, requestParameters.minWeight, requestParameters.maxWeight, requestParameters.sorting, requestParameters.gearGroupIds, requestParameters.speciesGroupIds, requestParameters.vesselLengthGroups, requestParameters.fiskeridirVesselIds, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for currentTrip operation in V1tripApi.
 * @export
 * @interface V1tripApiCurrentTripRequest
 */
export interface V1tripApiCurrentTripRequest {
    /**
     * 
     * @type {number}
     * @memberof V1tripApiCurrentTrip
     */
    readonly fiskeridirVesselId: number
}

/**
 * Request parameters for tripOfHaul operation in V1tripApi.
 * @export
 * @interface V1tripApiTripOfHaulRequest
 */
export interface V1tripApiTripOfHaulRequest {
    /**
     * 
     * @type {number}
     * @memberof V1tripApiTripOfHaul
     */
    readonly haulId: number
}

/**
 * Request parameters for tripOfLanding operation in V1tripApi.
 * @export
 * @interface V1tripApiTripOfLandingRequest
 */
export interface V1tripApiTripOfLandingRequest {
    /**
     * 
     * @type {string}
     * @memberof V1tripApiTripOfLanding
     */
    readonly landingId: string
}

/**
 * Request parameters for tripOfPartialLanding operation in V1tripApi.
 * @export
 * @interface V1tripApiTripOfPartialLandingRequest
 */
export interface V1tripApiTripOfPartialLandingRequest {
    /**
     * 
     * @type {string}
     * @memberof V1tripApiTripOfPartialLanding
     */
    readonly landingId: string
}

/**
 * Request parameters for trips operation in V1tripApi.
 * @export
 * @interface V1tripApiTripsRequest
 */
export interface V1tripApiTripsRequest {
    /**
     * 
     * @type {number}
     * @memberof V1tripApiTrips
     */
    readonly limit?: number

    /**
     * 
     * @type {number}
     * @memberof V1tripApiTrips
     */
    readonly offset?: number

    /**
     * 
     * @type {Ordering}
     * @memberof V1tripApiTrips
     */
    readonly ordering?: Ordering

    /**
     * 
     * @type {Array<string>}
     * @memberof V1tripApiTrips
     */
    readonly deliveryPoints?: Array<string>

    /**
     * 
     * @type {string}
     * @memberof V1tripApiTrips
     */
    readonly startDate?: string

    /**
     * 
     * @type {string}
     * @memberof V1tripApiTrips
     */
    readonly endDate?: string

    /**
     * 
     * @type {number}
     * @memberof V1tripApiTrips
     */
    readonly minWeight?: number

    /**
     * 
     * @type {number}
     * @memberof V1tripApiTrips
     */
    readonly maxWeight?: number

    /**
     * 
     * @type {TripSorting}
     * @memberof V1tripApiTrips
     */
    readonly sorting?: TripSorting

    /**
     * 
     * @type {Array<string>}
     * @memberof V1tripApiTrips
     */
    readonly gearGroupIds?: Array<string>

    /**
     * 
     * @type {Array<string>}
     * @memberof V1tripApiTrips
     */
    readonly speciesGroupIds?: Array<string>

    /**
     * 
     * @type {Array<string>}
     * @memberof V1tripApiTrips
     */
    readonly vesselLengthGroups?: Array<string>

    /**
     * 
     * @type {Array<number>}
     * @memberof V1tripApiTrips
     */
    readonly fiskeridirVesselIds?: Array<number>
}

/**
 * V1tripApi - object-oriented interface
 * @export
 * @class V1tripApi
 * @extends {BaseAPI}
 */
export class V1tripApi extends BaseAPI {
    /**
     * 
     * @param {V1tripApiCurrentTripRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1tripApi
     */
    public currentTrip(requestParameters: V1tripApiCurrentTripRequest, options?: AxiosRequestConfig) {
        return V1tripApiFp(this.configuration).currentTrip(requestParameters.fiskeridirVesselId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {V1tripApiTripOfHaulRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1tripApi
     */
    public tripOfHaul(requestParameters: V1tripApiTripOfHaulRequest, options?: AxiosRequestConfig) {
        return V1tripApiFp(this.configuration).tripOfHaul(requestParameters.haulId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {V1tripApiTripOfLandingRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1tripApi
     */
    public tripOfLanding(requestParameters: V1tripApiTripOfLandingRequest, options?: AxiosRequestConfig) {
        return V1tripApiFp(this.configuration).tripOfLanding(requestParameters.landingId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {V1tripApiTripOfPartialLandingRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1tripApi
     */
    public tripOfPartialLanding(requestParameters: V1tripApiTripOfPartialLandingRequest, options?: AxiosRequestConfig) {
        return V1tripApiFp(this.configuration).tripOfPartialLanding(requestParameters.landingId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {V1tripApiTripsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1tripApi
     */
    public trips(requestParameters: V1tripApiTripsRequest = {}, options?: AxiosRequestConfig) {
        return V1tripApiFp(this.configuration).trips(requestParameters.limit, requestParameters.offset, requestParameters.ordering, requestParameters.deliveryPoints, requestParameters.startDate, requestParameters.endDate, requestParameters.minWeight, requestParameters.maxWeight, requestParameters.sorting, requestParameters.gearGroupIds, requestParameters.speciesGroupIds, requestParameters.vesselLengthGroups, requestParameters.fiskeridirVesselIds, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * V1userApi - axios parameter creator
 * @export
 */
export const V1userApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1.0/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication auth0 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "auth0", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {User} user updated user information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser: async (user: User, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('updateUser', 'user', user)
            const localVarPath = `/v1.0/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication auth0 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "auth0", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(user, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * V1userApi - functional programming interface
 * @export
 */
export const V1userApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = V1userApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUser(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {User} user updated user information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUser(user: User, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser(user, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * V1userApi - factory interface
 * @export
 */
export const V1userApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = V1userApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(options?: AxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.getUser(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {V1userApiUpdateUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(requestParameters: V1userApiUpdateUserRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateUser(requestParameters.user, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for updateUser operation in V1userApi.
 * @export
 * @interface V1userApiUpdateUserRequest
 */
export interface V1userApiUpdateUserRequest {
    /**
     * updated user information
     * @type {User}
     * @memberof V1userApiUpdateUser
     */
    readonly user: User
}

/**
 * V1userApi - object-oriented interface
 * @export
 * @class V1userApi
 * @extends {BaseAPI}
 */
export class V1userApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1userApi
     */
    public getUser(options?: AxiosRequestConfig) {
        return V1userApiFp(this.configuration).getUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {V1userApiUpdateUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1userApi
     */
    public updateUser(requestParameters: V1userApiUpdateUserRequest, options?: AxiosRequestConfig) {
        return V1userApiFp(this.configuration).updateUser(requestParameters.user, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * V1vesselApi - axios parameter creator
 * @export
 */
export const V1vesselApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vessels: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1.0/vessels`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication auth0 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "auth0", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * V1vesselApi - functional programming interface
 * @export
 */
export const V1vesselApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = V1vesselApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async vessels(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Vessel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.vessels(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * V1vesselApi - factory interface
 * @export
 */
export const V1vesselApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = V1vesselApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vessels(options?: AxiosRequestConfig): AxiosPromise<Array<Vessel>> {
            return localVarFp.vessels(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * V1vesselApi - object-oriented interface
 * @export
 * @class V1vesselApi
 * @extends {BaseAPI}
 */
export class V1vesselApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1vesselApi
     */
    public vessels(options?: AxiosRequestConfig) {
        return V1vesselApiFp(this.configuration).vessels(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * V1vmsApi - axios parameter creator
 * @export
 */
export const V1vmsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} callSign 
         * @param {string} [start] 
         * @param {string} [end] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vmsPositions: async (callSign: string, start?: string, end?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'callSign' is not null or undefined
            assertParamExists('vmsPositions', 'callSign', callSign)
            const localVarPath = `/v1.0/vms/{call_sign}`
                .replace(`{${"call_sign"}}`, encodeURIComponent(String(callSign)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication auth0 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "auth0", [], configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = (start as any instanceof Date) ?
                    (start as any).toISOString() :
                    start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = (end as any instanceof Date) ?
                    (end as any).toISOString() :
                    end;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * V1vmsApi - functional programming interface
 * @export
 */
export const V1vmsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = V1vmsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} callSign 
         * @param {string} [start] 
         * @param {string} [end] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async vmsPositions(callSign: string, start?: string, end?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<VmsPosition>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.vmsPositions(callSign, start, end, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * V1vmsApi - factory interface
 * @export
 */
export const V1vmsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = V1vmsApiFp(configuration)
    return {
        /**
         * 
         * @param {V1vmsApiVmsPositionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vmsPositions(requestParameters: V1vmsApiVmsPositionsRequest, options?: AxiosRequestConfig): AxiosPromise<Array<VmsPosition>> {
            return localVarFp.vmsPositions(requestParameters.callSign, requestParameters.start, requestParameters.end, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for vmsPositions operation in V1vmsApi.
 * @export
 * @interface V1vmsApiVmsPositionsRequest
 */
export interface V1vmsApiVmsPositionsRequest {
    /**
     * 
     * @type {string}
     * @memberof V1vmsApiVmsPositions
     */
    readonly callSign: string

    /**
     * 
     * @type {string}
     * @memberof V1vmsApiVmsPositions
     */
    readonly start?: string

    /**
     * 
     * @type {string}
     * @memberof V1vmsApiVmsPositions
     */
    readonly end?: string
}

/**
 * V1vmsApi - object-oriented interface
 * @export
 * @class V1vmsApi
 * @extends {BaseAPI}
 */
export class V1vmsApi extends BaseAPI {
    /**
     * 
     * @param {V1vmsApiVmsPositionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1vmsApi
     */
    public vmsPositions(requestParameters: V1vmsApiVmsPositionsRequest, options?: AxiosRequestConfig) {
        return V1vmsApiFp(this.configuration).vmsPositions(requestParameters.callSign, requestParameters.start, requestParameters.end, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * V1weatherApi - axios parameter creator
 * @export
 */
export const V1weatherApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {Array<number>} [weatherLocationIds] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        weather: async (startDate?: string, endDate?: string, weatherLocationIds?: Array<number>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1.0/weather`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication auth0 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "auth0", [], configuration)

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any instanceof Date) ?
                    (startDate as any).toISOString() :
                    startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any instanceof Date) ?
                    (endDate as any).toISOString() :
                    endDate;
            }

            if (weatherLocationIds) {
                localVarQueryParameter['weatherLocationIds[]'] = weatherLocationIds;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        weatherLocations: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1.0/weather_locations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication auth0 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "auth0", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * V1weatherApi - functional programming interface
 * @export
 */
export const V1weatherApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = V1weatherApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} [startDate] 
         * @param {string} [endDate] 
         * @param {Array<number>} [weatherLocationIds] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async weather(startDate?: string, endDate?: string, weatherLocationIds?: Array<number>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Weather>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.weather(startDate, endDate, weatherLocationIds, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async weatherLocations(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WeatherLocation>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.weatherLocations(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * V1weatherApi - factory interface
 * @export
 */
export const V1weatherApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = V1weatherApiFp(configuration)
    return {
        /**
         * 
         * @param {V1weatherApiWeatherRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        weather(requestParameters: V1weatherApiWeatherRequest = {}, options?: AxiosRequestConfig): AxiosPromise<Array<Weather>> {
            return localVarFp.weather(requestParameters.startDate, requestParameters.endDate, requestParameters.weatherLocationIds, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        weatherLocations(options?: AxiosRequestConfig): AxiosPromise<Array<WeatherLocation>> {
            return localVarFp.weatherLocations(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for weather operation in V1weatherApi.
 * @export
 * @interface V1weatherApiWeatherRequest
 */
export interface V1weatherApiWeatherRequest {
    /**
     * 
     * @type {string}
     * @memberof V1weatherApiWeather
     */
    readonly startDate?: string

    /**
     * 
     * @type {string}
     * @memberof V1weatherApiWeather
     */
    readonly endDate?: string

    /**
     * 
     * @type {Array<number>}
     * @memberof V1weatherApiWeather
     */
    readonly weatherLocationIds?: Array<number>
}

/**
 * V1weatherApi - object-oriented interface
 * @export
 * @class V1weatherApi
 * @extends {BaseAPI}
 */
export class V1weatherApi extends BaseAPI {
    /**
     * 
     * @param {V1weatherApiWeatherRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1weatherApi
     */
    public weather(requestParameters: V1weatherApiWeatherRequest = {}, options?: AxiosRequestConfig) {
        return V1weatherApiFp(this.configuration).weather(requestParameters.startDate, requestParameters.endDate, requestParameters.weatherLocationIds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V1weatherApi
     */
    public weatherLocations(options?: AxiosRequestConfig) {
        return V1weatherApiFp(this.configuration).weatherLocations(options).then((request) => request(this.axios, this.basePath));
    }
}


